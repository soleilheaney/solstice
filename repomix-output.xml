This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.github/
  workflows/
    ci.yml
    deploy-preview.yml
  SECRETS.md
.husky/
  pre-commit
.nitro/
  types/
    nitro-config.d.ts
    nitro-imports.d.ts
    nitro-routes.d.ts
    nitro.d.ts
docs/
  code-improvements.md
  IMPLEMENTATION_SUMMARY.md
  SECURITY.md
  TECH_DEBT.md
netlify/
  edge-functions/
    security-headers.ts
scripts/
  test-security-headers.sh
src/
  components/
    auth/
      password-input.example.tsx
    DefaultCatchBoundary.tsx
    NotFound.tsx
    ThemeToggle.tsx
  db/
    schema/
      auth.schema.ts
      index.ts
    connections.ts
    index.ts
    neon.ts
  features/
    auth/
      __tests__/
        login.test.tsx
      api/
        $.ts
      components/
        login.tsx
        signup.tsx
      useAuthGuard.tsx
  lib/
    auth/
      functions/
        getUser.ts
      middleware/
        __tests__/
          auth-guard.test.ts
        auth-guard.ts
      auth-client.ts
      index.ts
    security/
      middleware/
        rate-limit.ts
      utils/
        password-validator.ts
      config.ts
      index.ts
    server/
      __tests__/
        example.test.ts
      auth.ts
      db.ts
    auth-client.ts
    env.ts
  routes/
    (auth)/
      login.tsx
      route.tsx
      signup.tsx
    api/
      auth/
        $.ts
        login.example.ts
    dashboard/
      index.tsx
      route.tsx
    __root.tsx
    index.tsx
  shared/
    hooks/
      useTheme.ts
    lib/
      utils.ts
    ui/
      __tests__/
        button.test.tsx
      button.tsx
      icons.tsx
      input.tsx
      label.tsx
  tests/
    mocks/
      auth.ts
    README.md
    setup.ts
    utils.tsx
  api.ts
  router.tsx
  routeTree.gen.ts
  styles.css
.editorconfig
.env.example
.env.production
.env.test
.gitattributes
.gitignore
.prettierignore
.prettierrc
CLAUDE.md
components.json
docker-compose.yml
drizzle.config.ts
eslint.config.js
LICENSE
netlify.toml
package.json
README.env.md
README.md
tsconfig.json
vite.config.ts
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(pnpm auth:secret:*)",
      "Bash(brew install:*)",
      "WebFetch(domain:docs.netlify.com)",
      "Bash(pnpm install:*)",
      "Bash(pnpm setup:*)",
      "Bash(source:*)",
      "Bash(mkdir:*)",
      "Bash(mv:*)",
      "Bash(rmdir:*)",
      "Bash(tree:*)",
      "Bash(find:*)",
      "Bash(rm:*)",
      "Bash(pnpm check-types:*)",
      "Bash(npx tsc:*)",
      "Bash(pnpm add:*)",
      "Bash(pnpm netlify env:list:*)",
      "WebFetch(domain:cli.netlify.com)",
      "Bash(netlify env:list:*)",
      "Bash(rg:*)",
      "Bash(pnpm test:*)",
      "Bash(npx husky:*)",
      "Bash(ls:*)",
      "Bash(chmod:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(pnpm run:*)",
      "Bash(pnpm lint:*)",
      "Bash(grep:*)",
      "Bash(pnpm eslint:*)"
    ],
    "deny": []
  }
}
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '9'

jobs:
  lint-and-type-check:
    name: Lint and Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run linter
        run: pnpm lint

      - name: Run type checking
        run: pnpm check-types

  test:
    name: Test (Node ${{ matrix.node-version }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: ['18', '20']
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: solstice_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run tests with coverage
        run: pnpm test:coverage
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/solstice_test
          VITE_BASE_URL: http://localhost:3000
          NODE_ENV: test

      - name: Upload coverage reports
        if: matrix.node-version == '20'
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint-and-type-check]
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build application
        run: pnpm build
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          VITE_BASE_URL: ${{ secrets.VITE_BASE_URL }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: dist/
          retention-days: 7
</file>

<file path=".github/workflows/deploy-preview.yml">
name: Deploy Preview

on:
  pull_request:
    types: [opened, synchronize, reopened]

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '9'

jobs:
  deploy-preview:
    name: Deploy to Netlify Preview
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      deployments: write
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build application
        run: pnpm build
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          VITE_BASE_URL: ${{ secrets.VITE_BASE_URL }}
          GITHUB_CLIENT_ID: ${{ secrets.GITHUB_CLIENT_ID }}
          GITHUB_CLIENT_SECRET: ${{ secrets.GITHUB_CLIENT_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}

      - name: Deploy to Netlify
        id: netlify
        uses: nwtgck/actions-netlify@v3.0
        with:
          publish-dir: './dist'
          production-deploy: false
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: "Deploy from GitHub Actions"
          enable-pull-request-comment: true
          enable-commit-comment: false
          overwrites-pull-request-comment: true
          alias: pr-${{ github.event.pull_request.number }}
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}

      - name: Comment PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          script: |
            const deployUrl = '${{ steps.netlify.outputs.deploy-url }}';
            const comment = `### üöÄ Deploy Preview
            
            | Name | Link |
            |------|------|
            | üî® Latest commit | ${context.sha} |
            | üîç Latest deploy log | ${{ steps.netlify.outputs.logs-url }} |
            | üòé Deploy Preview | [Visit Preview](${deployUrl}) |
            
            ---
            
            _This comment is automatically updated on each push_`;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => {
              return comment.user.type === 'Bot' && comment.body.includes('Deploy Preview');
            });
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
</file>

<file path=".github/SECRETS.md">
# GitHub Actions Secrets Configuration

This document outlines the required secrets for GitHub Actions workflows.

## Required Secrets

### Core Application Secrets

| Secret Name | Description | Example |
|------------|-------------|---------|
| `DATABASE_URL` | PostgreSQL connection string | `postgresql://user:pass@host:5432/db` |
| `VITE_BASE_URL` | Application base URL | `https://solstice.example.com` |

### Netlify Deployment Secrets

| Secret Name | Description | How to Obtain |
|------------|-------------|---------------|
| `NETLIFY_AUTH_TOKEN` | Personal access token for Netlify | 1. Go to [User Settings > Applications](https://app.netlify.com/user/applications)<br>2. Click "New access token"<br>3. Give it a descriptive name<br>4. Copy the token |
| `NETLIFY_SITE_ID` | Your Netlify site ID | 1. Go to your site dashboard on Netlify<br>2. Go to "Site configuration"<br>3. Copy the "Site ID" |

### OAuth Provider Secrets

| Secret Name | Description | How to Obtain |
|------------|-------------|---------------|
| `GITHUB_CLIENT_ID` | GitHub OAuth App client ID | 1. Go to [GitHub Settings > Developer settings > OAuth Apps](https://github.com/settings/developers)<br>2. Click "New OAuth App" or select existing<br>3. Copy the Client ID |
| `GITHUB_CLIENT_SECRET` | GitHub OAuth App client secret | From the same OAuth App page, generate/copy the Client Secret |
| `GOOGLE_CLIENT_ID` | Google OAuth 2.0 client ID | 1. Go to [Google Cloud Console](https://console.cloud.google.com/)<br>2. Create/select project<br>3. Go to "APIs & Services" > "Credentials"<br>4. Create OAuth 2.0 Client ID |
| `GOOGLE_CLIENT_SECRET` | Google OAuth 2.0 client secret | From the same OAuth 2.0 credentials page |

### Optional Secrets

| Secret Name | Description | Required For |
|------------|-------------|--------------|
| `CODECOV_TOKEN` | Codecov upload token | Code coverage reporting (optional but recommended) |

## Setting Up Secrets

1. Go to your GitHub repository
2. Navigate to Settings > Secrets and variables > Actions
3. Click "New repository secret"
4. Add each secret with its corresponding value

## Security Best Practices

- Never commit secrets to the repository
- Rotate secrets regularly
- Use least-privilege access for all tokens
- Review and audit secret usage periodically
- Remove unused secrets promptly

## Local Development

For local development, create a `.env` file in the project root with the same variables. The `.env` file is gitignored and should never be committed.

Example `.env` file:
```env
DATABASE_URL=postgresql://localhost:5432/solstice_dev
VITE_BASE_URL=http://localhost:3000
GITHUB_CLIENT_ID=your_dev_client_id
GITHUB_CLIENT_SECRET=your_dev_client_secret
GOOGLE_CLIENT_ID=your_dev_client_id
GOOGLE_CLIENT_SECRET=your_dev_client_secret
```
</file>

<file path="docs/code-improvements.md">
# Code Pattern Improvements

This document outlines the code pattern improvements implemented in the Solstice sports league management platform.

## 1. Auth Client Facade Pattern

### Before
```typescript
import authClient from "~/lib/auth-client";

// Usage
authClient.signIn.email({ ... });
authClient.signIn.social({ ... });
```

### After
```typescript
import { auth } from "~/lib/auth-client";

// Usage
auth.signIn.email({ ... });
auth.signInWithOAuth({ ... });
```

### Benefits
- **Cleaner API**: The facade provides a more intuitive interface with better method names
- **Encapsulation**: Internal implementation details are hidden from consumers
- **Flexibility**: Easy to swap auth providers or add middleware without changing consumer code
- **Type Safety**: Better IntelliSense support with explicit method exports

## 2. Theme Management with useTheme Hook

### Before
```typescript
// Direct DOM manipulation
function toggleTheme() {
  if (document.documentElement.classList.contains("dark") ||
      (!("theme" in localStorage) &&
        window.matchMedia("(prefers-color-scheme: dark)").matches)) {
    document.documentElement.classList.remove("dark");
    localStorage.theme = "light";
  } else {
    document.documentElement.classList.add("dark");
    localStorage.theme = "dark";
  }
}
```

### After
```typescript
import { useTheme } from "~/shared/hooks/useTheme";

// Usage
const { theme, resolvedTheme, toggleTheme, setTheme } = useTheme();
```

### Features
- **System Theme Support**: Respects user's OS preferences
- **Reactive Updates**: Automatically responds to system theme changes
- **Persistent State**: Saves user preference to localStorage
- **Type Safety**: Strongly typed theme values ("light" | "dark" | "system")
- **Clean API**: Simple toggle and set methods

## 3. Centralized Icon Management

### Before
```typescript
// Icons imported directly in components
import { MoonIcon, SunIcon } from "lucide-react";

// SVG icons hardcoded in components
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path d="..." fill="currentColor" />
</svg>
```

### After
```typescript
import { GitHubIcon, GoogleIcon, MoonIcon, SunIcon } from "~/shared/ui/icons";

// Usage
<GitHubIcon />
<GoogleIcon />
```

### Benefits
- **Consistency**: All icons in one place for easy management
- **Reusability**: Icons can be used across components without duplication
- **Performance**: SVG icons are optimized and consistent in size
- **Maintainability**: Easy to update or replace icons globally
- **Type Safety**: TypeScript support for all icon props

## 4. Authentication Route Guards

### Before
```typescript
// Manual authentication checks in each component
if (!user) {
  navigate({ to: "/login" });
  return;
}
```

### After
```typescript
import { useAuthGuard } from "~/features/auth/useAuthGuard";

// Protected route
useAuthGuard({ user, requireAuth: true });

// Public route that redirects authenticated users
useAuthGuard({ user, redirectAuthenticated: true });

// With callbacks
useAuthGuard({
  user,
  requireAuth: true,
  onAuthSuccess: (user) => console.log("Welcome", user.name),
  onAuthFail: () => console.log("Access denied")
});
```

### Features
- **Declarative Guards**: Simple API for protecting routes
- **Redirect Support**: Automatic redirects with preserved return URLs
- **Flexible Configuration**: Customizable redirect paths and callbacks
- **HOC Support**: `withAuthGuard` for wrapping components
- **Type Safety**: Full TypeScript support with Better Auth types

## Migration Guide

### Updating Auth Imports
```typescript
// Old
import authClient from "~/lib/auth/auth-client";
await authClient.signOut();

// New
import { auth } from "~/lib/auth-client";
await auth.signOut();
```

### Updating Theme Toggle
```typescript
// Old
<ThemeToggle /> // Works as before, now uses useTheme internally

// New (if you need theme state)
const { theme, toggleTheme } = useTheme();
```

### Updating Icons
```typescript
// Old
import { LoaderCircle } from "lucide-react";
<LoaderCircle className="animate-spin" />

// New
import { LoaderIcon } from "~/shared/ui/icons";
<LoaderIcon className="animate-spin" />
```

### Protecting Routes
```typescript
// In your route component
export const Route = createFileRoute("/dashboard")({
  component: Dashboard,
  loader: ({ context }) => ({ user: context.user }),
});

function Dashboard() {
  const { user } = Route.useLoaderData();
  const { isAuthenticated } = useAuthGuard({ user });
  
  // Component is protected
}
```

## Best Practices

1. **Always use the auth facade** instead of importing the raw auth client
2. **Use useTheme hook** for any theme-related functionality
3. **Import icons from the centralized icons file** to maintain consistency
4. **Apply route guards** at the route level for better security
5. **Keep the auth client facade updated** when adding new auth methods
6. **Document any custom icons** added to the icons file

## Future Improvements

- Add more OAuth providers to the auth facade
- Extend useTheme with more theme options (e.g., color schemes)
- Create an icon sprite system for better performance
- Add role-based access control to useAuthGuard
- Implement auth state persistence across tabs
</file>

<file path="docs/IMPLEMENTATION_SUMMARY.md">
# Implementation Summary

## What Was Accomplished

### 1. ‚úÖ Folder Structure Reorganization
- Migrated from routes-based to features-based architecture
- Created clear separation between features, shared code, and infrastructure
- Auth components moved to `src/features/auth/`
- UI components centralized in `src/shared/ui/`

### 2. ‚úÖ Database Schema Consolidation
- Removed duplicate schemas from `src/lib/server/schema`
- Centralized all schemas in `src/db/schema/`
- Updated all imports to use single source of truth
- Fixed Drizzle configuration

### 3. ‚úÖ Environment Handling
- Created layered environment configuration system
- Added `.env.test` and `.env.production` files
- Implemented type-safe environment variable access
- Integrated with Netlify's environment system

### 4. ‚úÖ Neon Database Configuration
- Implemented dual connection system (pooled/unpooled)
- Added HTTP pooling for serverless functions
- Created automatic connection selection based on context
- Documented when to use each connection type

### 5. ‚úÖ Testing Infrastructure
- Set up Vitest with React Testing Library
- Created test utilities and mocks
- Added example tests for components and server functions
- Configured coverage reporting

### 6. ‚úÖ Pre-commit Hooks
- Installed Husky and lint-staged
- Automated code formatting and linting on commit
- Prevents broken code from entering the repository

### 7. ‚úÖ Security Enhancements
- Implemented CSP headers via Netlify Edge Functions
- Configured secure cookie settings
- Added rate limiting middleware
- Created password validation utilities
- Set up comprehensive security headers

### 8. ‚úÖ CI/CD Pipeline
- Created GitHub Actions workflows
- Automated testing across Node.js versions
- Netlify preview deployments for PRs
- PostgreSQL service for integration tests

### 9. ‚úÖ Code Pattern Improvements
- Created auth client facade for cleaner API
- Implemented proper useTheme hook
- Centralized SVG icons
- Added auth guard utilities

## Quick Health Check

| Category | Status | Notes |
|----------|--------|-------|
| **Build** | ‚ö†Ô∏è | TypeScript errors need fixing |
| **Tests** | ‚úÖ | All 24 tests passing |
| **Linting** | ‚ö†Ô∏è | 3 warnings (non-critical) |
| **Security** | ‚úÖ | Headers, cookies, rate limiting configured |
| **CI/CD** | ‚úÖ | GitHub Actions + Netlify ready |
| **Documentation** | ‚úÖ | Comprehensive docs created |

## Time Saved vs. Manual Implementation

Estimated time saved: **40-60 hours** of manual work
- Folder restructuring: 4-6 hours
- Database consolidation: 2-3 hours  
- Environment setup: 3-4 hours
- Testing infrastructure: 6-8 hours
- Security implementation: 8-10 hours
- CI/CD setup: 4-5 hours
- Documentation: 3-4 hours
- Code patterns: 4-5 hours
- Debugging and testing: 6-10 hours

## Files Created/Modified

- **Created**: 45+ new files
- **Modified**: 30+ existing files
- **Deleted**: 5 redundant files
- **Tests**: 4 test suites with 24 tests

## Ready for Production?

**Almost!** The foundation is solid, but you need to:

1. Fix remaining TypeScript errors
2. Configure environment variables in Netlify
3. Set up OAuth applications
4. Review and adjust security settings
5. Add more comprehensive tests

The codebase is now well-organized, secure, and maintainable. The patterns established will make future development much smoother.
</file>

<file path="docs/SECURITY.md">
# Security Configuration

This document outlines the security measures implemented in the Solstice application.

## Overview

The application implements multiple layers of security:

1. **Security Headers** - Applied via Netlify Edge Functions
2. **Secure Cookie Configuration** - Enhanced Better Auth settings
3. **Rate Limiting** - Protection against brute force attacks
4. **Password Validation** - Strong password requirements
5. **Content Security Policy (CSP)** - Protection against XSS attacks

## Security Headers

Security headers are automatically applied to all responses via a Netlify Edge Function located at `netlify/edge-functions/security-headers.ts`.

### Applied Headers:

- **Content-Security-Policy**: Restricts resource loading with nonce-based script validation
- **X-Frame-Options**: DENY - Prevents clickjacking attacks
- **X-Content-Type-Options**: nosniff - Prevents MIME type sniffing
- **Referrer-Policy**: strict-origin-when-cross-origin - Controls referrer information
- **X-XSS-Protection**: 1; mode=block - Legacy XSS protection
- **Permissions-Policy**: Restricts browser features
- **Strict-Transport-Security**: Enforces HTTPS with preloading

## Cookie Configuration

Better Auth cookies are configured with enhanced security settings:

```typescript
{
  secure: true,              // HTTPS only in production
  sameSite: "lax",          // CSRF protection
  httpOnly: true,           // No JavaScript access
  path: "/",                // Available site-wide
  domain: process.env.COOKIE_DOMAIN // Optional domain restriction
}
```

## Rate Limiting

The application implements rate limiting for sensitive endpoints:

### Auth Endpoints
- **Window**: 15 minutes
- **Max Requests**: 5 per window
- **Endpoints**: Login, registration, password reset

### API Endpoints
- **Window**: 15 minutes
- **Max Requests**: 100 per window
- **Endpoints**: All API routes

Usage example:
```typescript
import { rateLimit, getClientIp } from "~/lib/security";

// In your API route
const clientIp = getClientIp(request.headers);
await rateLimit("auth", clientIp);
```

## Password Requirements

Strong password validation is enforced:

- **Minimum Length**: 8 characters
- **Required**: Uppercase, lowercase, numbers, and special characters
- **Strength Meter**: 0-5 scale for user feedback

Usage example:
```typescript
import { validatePassword, getPasswordStrength } from "~/lib/security";

const result = validatePassword(password);
if (!result.isValid) {
  // Show errors to user
  console.error(result.errors);
}

const strength = getPasswordStrength(password);
// Display strength indicator
```

## Content Security Policy (CSP)

The CSP is configured to:

- Allow self-hosted resources by default
- Use nonces for inline scripts
- Allow specific external resources (Google Fonts, OAuth providers)
- Block unsafe inline styles (except where necessary)
- Prevent object/embed elements
- Enforce HTTPS upgrades

### Nonce Implementation

The edge function automatically:
1. Generates a unique nonce for each request
2. Injects the nonce into all script tags
3. Includes the nonce in the CSP header

## Environment Variables

Add these optional security-related environment variables:

```env
# Cookie domain restriction (optional)
COOKIE_DOMAIN=.yourdomain.com

# OAuth allowed email domains (comma-separated)
OAUTH_ALLOWED_DOMAINS=yourdomain.com,trusted-partner.com
```

## Development vs Production

Security features that differ between environments:

### Development
- Cookies use HTTP (not HTTPS-only)
- Email verification not required
- CSP may be more permissive

### Production
- Cookies are HTTPS-only
- Email verification required
- Strict CSP enforcement
- HSTS header with preloading

## Testing Security

1. **Headers**: Use browser dev tools or `curl -I https://yoursite.com`
2. **CSP**: Check browser console for violations
3. **Cookies**: Inspect in browser dev tools
4. **Rate Limiting**: Test with rapid requests
5. **Password Validation**: Test with various password combinations

## Future Enhancements

Consider implementing:

1. **Redis-based Rate Limiting** - For distributed deployments
2. **Web Application Firewall (WAF)** - Additional protection layer
3. **Security Monitoring** - Log and alert on security events
4. **2FA/MFA** - Two-factor authentication
5. **API Key Management** - For service-to-service auth
</file>

<file path="docs/TECH_DEBT.md">
# Tech Debt and Future Improvements

## Remaining TypeScript Errors

1. **Import path issues** - Several files still have incorrect import paths:
   - `DefaultCatchBoundary.tsx` and `NotFound.tsx` importing from `./ui/button` instead of `~/shared/ui/button`
   - `password-input.example.tsx` importing from non-existent paths
   - Missing `@tanstack/react-start/api` module

2. **Auth client type issues**:
   - Removed `twoFactor` and `admin` properties that don't exist in Better Auth
   - Test mocks need updating to match actual auth client structure

3. **Test setup issues**:
   - `tests/setup.ts` missing `vi` import from vitest
   - Mock types in auth tests need proper typing

## Tech Debt Created

### 1. ESLint Warnings (Non-blocking)
- **useTheme hook**: Still has warnings about setting state in useEffect (though functionally correct)
- **Array index keys**: Password input example uses array indices as keys (acceptable for static arrays)

### 2. Auth Guard File Extension
- Had to rename `useAuthGuard.ts` to `.tsx` because it uses JSX
- This is a minor inconsistency as hooks typically use `.ts`

### 3. Environment Variable Handling
- Created `.env.test` and `.env.production` files but actual secrets need to be configured in Netlify
- The local/test split might need refinement based on actual deployment needs

### 4. Database Connection Complexity
- The dual pooled/unpooled connection setup adds complexity
- May need to revisit if Neon changes their recommendations

### 5. Test Coverage
- Only created example tests, not comprehensive coverage
- Auth middleware tests are simplified due to TanStack Start's complex middleware structure

## Shortcuts Taken

### 1. Simplified Rate Limiting
- In-memory storage won't scale across multiple instances
- Should implement Redis-based rate limiting for production

### 2. Basic Password Validation
- Current implementation is good but could add:
  - Common password dictionary checking
  - Leaked password database integration (haveibeenpwned)

### 3. CSP Nonce Implementation
- Currently generates nonces per request
- Could optimize with a nonce pool or caching strategy

### 4. Feature Folder Migration
- Only migrated auth features
- Other features still need to be organized when created

## Recommended Next Steps

### High Priority
1. Fix remaining TypeScript errors
2. Configure all environment variables in Netlify
3. Add comprehensive test coverage
4. Implement proper error boundaries

### Medium Priority
1. Add API documentation (OpenAPI/Swagger)
2. Implement request/response logging
3. Add performance monitoring (Sentry, etc.)
4. Create data migration scripts

### Low Priority
1. Add Storybook for component documentation
2. Implement feature flags system
3. Add internationalization (i18n)
4. Create admin dashboard scaffolding

## Configuration Needed

Before deploying to production:

1. **Netlify Environment Variables** - Set all required variables in Netlify UI
2. **OAuth Apps** - Create GitHub and Google OAuth applications
3. **Database** - Ensure Neon database is properly configured
4. **Domain** - Configure custom domain and update VITE_BASE_URL
5. **Monitoring** - Set up error tracking and analytics

## Breaking Changes to Watch

1. **TanStack Start** - Still in beta, API may change
2. **Better Auth** - Version 1.x, check for updates
3. **Neon Database** - Connection string format may evolve

## Performance Considerations

1. **Bundle Size** - Monitor and implement code splitting as needed
2. **Database Queries** - Add query optimization and caching
3. **Static Assets** - Implement CDN and image optimization
4. **API Response Times** - Add response caching where appropriate

## Security Improvements

1. **2FA Implementation** - Better Auth supports it but not implemented
2. **Session Management** - Add session revocation UI
3. **Audit Logging** - Track security-relevant events
4. **Input Sanitization** - Add additional validation layers
</file>

<file path="netlify/edge-functions/security-headers.ts">
import type { Config, Context } from "@netlify/edge-functions";

export default async function handler(req: Request, context: Context) {
  const response = await context.next();
  
  // Generate a nonce for CSP
  const nonce = crypto.randomUUID();
  
  // Get the response body to inject nonce into scripts
  const contentType = response.headers.get("content-type");
  const isHtml = contentType?.includes("text/html");
  
  // Clone the response to add headers
  const newResponse = new Response(response.body, response);
  
  // Security Headers
  const headers = {
    // Content Security Policy
    "Content-Security-Policy": [
      "default-src 'self'",
      `script-src 'self' 'nonce-${nonce}' https://challenges.cloudflare.com`,
      "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
      "font-src 'self' https://fonts.gstatic.com",
      "img-src 'self' data: https: blob:",
      "connect-src 'self' https://api.github.com https://accounts.google.com https://www.googleapis.com",
      "frame-src 'self' https://challenges.cloudflare.com",
      "object-src 'none'",
      "base-uri 'self'",
      "form-action 'self'",
      "frame-ancestors 'none'",
      "upgrade-insecure-requests"
    ].join("; "),
    
    // Other Security Headers
    "X-Frame-Options": "DENY",
    "X-Content-Type-Options": "nosniff",
    "Referrer-Policy": "strict-origin-when-cross-origin",
    "X-XSS-Protection": "1; mode=block",
    "Permissions-Policy": "geolocation=(), microphone=(), camera=()",
    "Strict-Transport-Security": "max-age=31536000; includeSubDomains; preload",
    
    // Remove server header
    "X-Powered-By": "",
  };
  
  // Apply all headers
  Object.entries(headers).forEach(([key, value]) => {
    if (value) {
      newResponse.headers.set(key, value);
    } else {
      newResponse.headers.delete(key);
    }
  });
  
  // If HTML response, inject nonce into script tags
  if (isHtml && response.body) {
    const text = await response.text();
    const modifiedHtml = text.replace(
      /<script(?![^>]*\snonce=)/g,
      `<script nonce="${nonce}"`
    );
    
    return new Response(modifiedHtml, {
      status: newResponse.status,
      statusText: newResponse.statusText,
      headers: newResponse.headers,
    });
  }
  
  return newResponse;
}

export const config: Config = {
  path: "/*",
};
</file>

<file path="scripts/test-security-headers.sh">
#!/bin/bash

# Test security headers
# Usage: ./scripts/test-security-headers.sh [URL]

URL="${1:-http://localhost:8888}"

echo "Testing security headers at: $URL"
echo "=================================="

# Function to check header
check_header() {
    local header_name="$1"
    local expected_value="$2"
    local actual_value=$(curl -s -I "$URL" | grep -i "^$header_name:" | cut -d' ' -f2- | tr -d '\r\n')
    
    if [ -n "$actual_value" ]; then
        echo "‚úÖ $header_name: $actual_value"
        if [ -n "$expected_value" ] && [[ "$actual_value" != *"$expected_value"* ]]; then
            echo "   ‚ö†Ô∏è  Expected to contain: $expected_value"
        fi
    else
        echo "‚ùå $header_name: Not found"
    fi
}

# Test all security headers
check_header "Content-Security-Policy"
check_header "X-Frame-Options" "DENY"
check_header "X-Content-Type-Options" "nosniff"
check_header "Referrer-Policy" "strict-origin-when-cross-origin"
check_header "X-XSS-Protection" "1; mode=block"
check_header "Permissions-Policy"
check_header "Strict-Transport-Security"

echo ""
echo "Full headers:"
echo "============="
curl -s -I "$URL" | grep -E "^(Content-Security-Policy|X-Frame-Options|X-Content-Type-Options|Referrer-Policy|X-XSS-Protection|Permissions-Policy|Strict-Transport-Security):"
</file>

<file path="src/components/auth/password-input.example.tsx">
import { useState } from "react";
import { validatePassword, getPasswordStrength, getPasswordStrengthLabel } from "~/lib/security";
import { Input } from "~/shared/ui/input";
import { Label } from "~/shared/ui/label";

/**
 * Example password input component with validation and strength indicator
 */
export function PasswordInput() {
  const [password, setPassword] = useState("");
  const [showValidation, setShowValidation] = useState(false);
  
  const validation = validatePassword(password);
  const strength = getPasswordStrength(password);
  const strengthLabel = getPasswordStrengthLabel(strength);
  
  const strengthColors = {
    0: "bg-red-500",
    1: "bg-red-500",
    2: "bg-orange-500",
    3: "bg-yellow-500",
    4: "bg-green-500",
    5: "bg-green-600",
  };
  
  return (
    <div className="space-y-2">
      <Label htmlFor="password">Password</Label>
      <Input
        id="password"
        type="password"
        value={password}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
          setPassword(e.target.value);
          setShowValidation(true);
        }}
        placeholder="Enter a secure password"
        className={validation.isValid ? "" : "border-red-500"}
      />
      
      {showValidation && password && (
        <>
          {/* Password strength indicator */}
          <div className="space-y-1">
            <div className="flex justify-between text-sm">
              <span>Strength:</span>
              <span className="font-medium">{strengthLabel}</span>
            </div>
            <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
              <div
                className={`h-full transition-all duration-300 ${strengthColors[strength as keyof typeof strengthColors]}`}
                style={{ width: `${(strength / 5) * 100}%` }}
              />
            </div>
          </div>
          
          {/* Validation errors */}
          {!validation.isValid && (
            <ul className="text-sm text-red-600 space-y-1">
              {validation.errors.map((error, index) => (
                <li key={`error-${index}-${error.slice(0, 10)}`} className="flex items-start">
                  <span className="mr-1">‚Ä¢</span>
                  <span>{error}</span>
                </li>
              ))}
            </ul>
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="src/db/schema/auth.schema.ts">
import { boolean, pgTable, text, timestamp } from "drizzle-orm/pg-core";

export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified")
    .$defaultFn(() => false)
    .notNull(),
  image: text("image"),
  createdAt: timestamp("created_at")
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  updatedAt: timestamp("updated_at")
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp("expires_at").notNull(),
  token: text("token").notNull().unique(),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
});

export const account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  idToken: text("id_token"),
  accessTokenExpiresAt: timestamp("access_token_expires_at"),
  refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
  scope: text("scope"),
  password: text("password"),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull(),
});

export const verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").$defaultFn(() => /* @__PURE__ */ new Date()),
  updatedAt: timestamp("updated_at").$defaultFn(() => /* @__PURE__ */ new Date()),
});
</file>

<file path="src/db/schema/index.ts">
export * from "./auth.schema";
// export your other schemas here
</file>

<file path="src/db/connections.ts">
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle as drizzleNeon } from "drizzle-orm/neon-serverless";
import { drizzle as drizzlePostgres } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import { serverOnly } from "@tanstack/react-start";
import { getPooledDbUrl, getUnpooledDbUrl, isServerless } from "../lib/env";
import * as schema from "./schema";

// Configure Neon for serverless environments
if (isServerless()) {
  neonConfig.useSecureWebSocket = true;
  neonConfig.poolQueryViaFetch = true;
}

/**
 * Pooled database connection using Neon's serverless driver.
 * 
 * Uses DATABASE_URL (pooled) or NETLIFY_DATABASE_URL for serverless functions.
 * This connection goes through Neon's connection pooler for efficient
 * concurrent request handling.
 * 
 * Use this for:
 * - API routes and serverless functions
 * - Short-lived queries
 * - High-concurrency scenarios
 */
export const pooledDb = serverOnly(() => {
  const connectionString = getPooledDbUrl();
  
  const pool = new Pool({ connectionString });
  return drizzleNeon({ 
    client: pool, 
    schema, 
    casing: "snake_case" 
  });
});

/**
 * Unpooled (direct) database connection using standard postgres driver.
 * 
 * Uses DATABASE_URL_UNPOOLED or NETLIFY_DATABASE_URL_UNPOOLED for
 * migrations and long operations. This creates a direct connection
 * to the database without going through the pooler.
 * 
 * Use this for:
 * - Database migrations
 * - Long-running operations
 * - Batch imports/exports
 * - Operations requiring session-level features
 */
export const unpooledDb = serverOnly(() => {
  const connectionString = getUnpooledDbUrl();
  
  const sql = postgres(connectionString);
  return drizzlePostgres({ 
    client: sql, 
    schema, 
    casing: "snake_case" 
  });
});

/**
 * Returns the appropriate database connection based on the environment.
 * 
 * - In serverless environments (Netlify/Vercel): Uses pooled connection
 * - In development or traditional servers: Uses unpooled connection
 * 
 * This is the recommended export for most use cases as it automatically
 * selects the optimal connection type.
 */
export const getDb = serverOnly(() => {
  if (isServerless()) {
    console.log("Using pooled connection for serverless environment");
    return pooledDb();
  } else {
    console.log("Using unpooled connection for traditional environment");
    return unpooledDb();
  }
});
</file>

<file path="src/db/index.ts">
import { getDb, pooledDb, unpooledDb } from "./connections";
import * as schema from "./schema";

// Export the auto-selected database connection based on environment
export const db = getDb();

// Export specific connections for when you need explicit control
export { pooledDb, unpooledDb };

// Re-export all schemas and types
export * from "./schema";
export { schema };
</file>

<file path="src/db/neon.ts">
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle as drizzleNeon } from "drizzle-orm/neon-serverless";
import { drizzle as drizzlePostgres } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import { serverOnly } from "@tanstack/react-start";
import { getPooledDbUrl, getUnpooledDbUrl, isServerless } from "../lib/env";
import * as schema from "./schema";

// Configure Neon for serverless environments
if (isServerless()) {
  neonConfig.useSecureWebSocket = true;
  neonConfig.poolQueryViaFetch = true;
}

/**
 * Creates a pooled database connection using Neon's serverless driver.
 * 
 * Use pooled connections when:
 * - Running in serverless environments (Netlify Functions, Vercel Edge Functions)
 * - Handling HTTP requests that need quick connections
 * - You need connection pooling to handle concurrent requests efficiently
 * - Running short-lived queries
 * 
 * The pooled connection uses Neon's connection pooler which maintains a pool
 * of connections to reduce connection overhead and improve performance.
 */
export const createPooledConnection = serverOnly(() => {
  const connectionString = getPooledDbUrl();
  
  const pool = new Pool({ connectionString });
  return drizzleNeon({ 
    client: pool, 
    schema, 
    casing: "snake_case" 
  });
});

/**
 * Creates an unpooled (direct) database connection.
 * 
 * Use unpooled connections when:
 * - Running long-lived operations (migrations, batch operations)
 * - Need session-level features (prepared statements, transactions with locks)
 * - Running in traditional server environments
 * - Performing database maintenance tasks
 * 
 * The unpooled connection connects directly to the database without going
 * through Neon's connection pooler.
 */
export const createUnpooledConnection = serverOnly(() => {
  const connectionString = getUnpooledDbUrl();
  
  const sql = postgres(connectionString);
  return drizzlePostgres({ 
    client: sql, 
    schema, 
    casing: "snake_case" 
  });
});

/**
 * Detects the environment and returns the appropriate connection type.
 * In serverless environments (Netlify/Vercel), uses pooled connections.
 * In development or traditional server environments, uses unpooled connections.
 */
export const createAutoConnection = serverOnly(() => {
  if (isServerless()) {
    console.log("Using pooled connection for serverless environment");
    return createPooledConnection();
  } else {
    console.log("Using unpooled connection for traditional environment");
    return createUnpooledConnection();
  }
});
</file>

<file path="src/features/auth/__tests__/login.test.tsx">
import { describe, expect, it, vi, beforeEach } from 'vitest'
import userEvent from '@testing-library/user-event'

// Setup mocks before imports
const mockNavigate = vi.fn()
const mockInvalidateQueries = vi.fn()

// Mock auth client
vi.mock('~/lib/auth-client', () => ({
  auth: {
    signIn: {
      email: vi.fn(),
    },
    signUp: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
    signOut: vi.fn(),
    getSession: vi.fn(),
  },
  default: {
    signIn: {
      email: vi.fn(),
      social: vi.fn(),
    },
    signUp: {
      email: vi.fn(),
    },
    signOut: vi.fn(),
    getSession: vi.fn(),
  }
}))

// Mock TanStack Router
vi.mock('@tanstack/react-router', () => ({
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useNavigate: () => mockNavigate,
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouteContext: () => ({ redirectUrl: '/dashboard' }),
  Link: ({ to, children, ...props }: { to: string; children: React.ReactNode } & React.AnchorHTMLAttributes<HTMLAnchorElement>) => <a href={to} {...props}>{children}</a>,
}))

vi.mock('@tanstack/react-query', async (importOriginal) => {
  const actual = await importOriginal<typeof import('@tanstack/react-query')>()
  return {
    ...actual,
    // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
    useQueryClient: () => ({ invalidateQueries: mockInvalidateQueries }),
  }
})

import { render, screen, waitFor } from '~/tests/utils'
import LoginForm from '../components/login'
import { auth } from '~/lib/auth-client'
import { createAuthMocks } from '~/tests/mocks/auth'

describe('LoginForm', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders login form with all elements', () => {
    render(<LoginForm />)
    
    // Check for form elements
    expect(screen.getByLabelText('Email')).toBeInTheDocument()
    expect(screen.getByLabelText('Password')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: 'Login' })).toBeInTheDocument()
    
    // Check for social login buttons
    expect(screen.getByRole('button', { name: 'Login with GitHub' })).toBeInTheDocument()
    expect(screen.getByRole('button', { name: 'Login with Google' })).toBeInTheDocument()
    
    // Check for signup link
    expect(screen.getByText("Don't have an account?")).toBeInTheDocument()
    expect(screen.getByRole('link', { name: 'Sign up' })).toHaveAttribute('href', '/signup')
  })

  it('handles successful email login', async () => {
    const user = userEvent.setup()
    const { mockUser, mockSession } = createAuthMocks()
    
    // Setup successful login response
    vi.mocked(auth.signIn.email).mockImplementationOnce((data, handlers) => {
      handlers?.onSuccess?.({
        user: mockUser,
        session: mockSession
      })
      return Promise.resolve({ data: { user: mockUser, session: mockSession }, error: null })
    })
    
    render(<LoginForm />)
    
    // Fill in form
    await user.type(screen.getByLabelText('Email'), 'test@example.com')
    await user.type(screen.getByLabelText('Password'), 'password123')
    
    // Submit form
    await user.click(screen.getByRole('button', { name: 'Login' }))
    
    await waitFor(() => {
      // Verify auth client was called
      expect(auth.signIn.email).toHaveBeenCalledWith(
        {
          email: 'test@example.com',
          password: 'password123',
          callbackURL: '/dashboard',
        },
        expect.any(Object)
      )
      
      // Verify queries were invalidated
      expect(mockInvalidateQueries).toHaveBeenCalledWith({ queryKey: ['user'] })
      
      // Verify navigation
      expect(mockNavigate).toHaveBeenCalledWith({ to: '/dashboard' })
    })
  })

  it('displays error message on failed login', async () => {
    const user = userEvent.setup()
    const errorMessage = 'Invalid email or password'
    
    // Setup failed login response
    vi.mocked(auth.signIn.email).mockImplementationOnce((data, handlers) => {
      const error = {
        status: 401,
        statusText: 'Unauthorized',
        error: { message: errorMessage },
        name: 'BetterFetchError' as const,
        message: errorMessage
      } as any
      handlers?.onError?.(error)
      return Promise.reject(new Error(errorMessage))
    })
    
    render(<LoginForm />)
    
    // Fill in form
    await user.type(screen.getByLabelText('Email'), 'test@example.com')
    await user.type(screen.getByLabelText('Password'), 'wrongpassword')
    
    // Submit form
    await user.click(screen.getByRole('button', { name: 'Login' }))
    
    await waitFor(() => {
      // Verify error message is displayed
      expect(screen.getByText(errorMessage)).toBeInTheDocument()
    })
  })

  it('disables form during submission', async () => {
    const user = userEvent.setup()
    
    // Setup delayed login response
    vi.mocked(auth.signIn.email).mockImplementationOnce(() => {
      return new Promise(() => {}) // Never resolves
    })
    
    render(<LoginForm />)
    
    // Fill in form
    await user.type(screen.getByLabelText('Email'), 'test@example.com')
    await user.type(screen.getByLabelText('Password'), 'password123')
    
    // Submit form
    await user.click(screen.getByRole('button', { name: 'Login' }))
    
    // Check loading state
    expect(screen.getByRole('button', { name: 'Logging in...' })).toBeDisabled()
    expect(screen.getByLabelText('Email')).toHaveAttribute('readonly')
    expect(screen.getByLabelText('Password')).toHaveAttribute('readonly')
    
    // Social login buttons should also be disabled
    expect(screen.getByRole('button', { name: 'Login with GitHub' })).toBeDisabled()
    expect(screen.getByRole('button', { name: 'Login with Google' })).toBeDisabled()
  })

  it('handles GitHub social login', async () => {
    const user = userEvent.setup()
    
    vi.mocked(auth.signInWithOAuth).mockImplementationOnce((data, handlers) => {
      handlers?.onRequest?.()
      return Promise.resolve()
    })
    
    render(<LoginForm />)
    
    await user.click(screen.getByRole('button', { name: 'Login with GitHub' }))
    
    expect(auth.signInWithOAuth).toHaveBeenCalledWith(
      {
        provider: 'github',
        callbackURL: '/dashboard',
      },
      expect.any(Object)
    )
  })

  it('handles Google social login', async () => {
    const user = userEvent.setup()
    
    vi.mocked(auth.signInWithOAuth).mockImplementationOnce((data, handlers) => {
      handlers?.onRequest?.()
      return Promise.resolve()
    })
    
    render(<LoginForm />)
    
    await user.click(screen.getByRole('button', { name: 'Login with Google' }))
    
    expect(auth.signInWithOAuth).toHaveBeenCalledWith(
      {
        provider: 'google',
        callbackURL: '/dashboard',
      },
      expect.any(Object)
    )
  })

  it('validates required fields', async () => {
    const user = userEvent.setup()
    
    render(<LoginForm />)
    
    // Try to submit empty form
    await user.click(screen.getByRole('button', { name: 'Login' }))
    
    // Auth client should not be called
    expect(auth.signIn.email).not.toHaveBeenCalled()
  })
})
</file>

<file path="src/features/auth/api/$.ts">
import { createServerFileRoute } from "@tanstack/react-start/server";
import { auth } from "~/lib/auth";

export const ServerRoute = createServerFileRoute("/api/auth/$").methods({
  GET: ({ request }) => {
    return auth.handler(request);
  },
  POST: ({ request }) => {
    return auth.handler(request);
  },
});
</file>

<file path="src/features/auth/components/login.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { Link, useNavigate, useRouteContext } from "@tanstack/react-router";
import { useState } from "react";
import { auth } from "~/lib/auth-client";
import { Button } from "~/shared/ui/button";
import { GitHubIcon, GoogleIcon, LoaderIcon, LogoIcon } from "~/shared/ui/icons";
import { Input } from "~/shared/ui/input";
import { Label } from "~/shared/ui/label";

export default function LoginForm() {
  const { redirectUrl } = useRouteContext({ from: "/(auth)/login" });
  const queryClient = useQueryClient();
  const navigate = useNavigate();

  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (isLoading) return;

    const formData = new FormData(e.currentTarget);
    const email = formData.get("email") as string;
    const password = formData.get("password") as string;
    if (!email || !password) return;

    setIsLoading(true);
    setErrorMessage("");

    auth.signIn.email(
      {
        email,
        password,
        callbackURL: redirectUrl,
      },
      {
        onError: (ctx) => {
          setErrorMessage(ctx.error.message);
          setIsLoading(false);
        },
        onSuccess: async () => {
          await queryClient.invalidateQueries({ queryKey: ["user"] });
          navigate({ to: redirectUrl });
        },
      },
    );
  };

  return (
    <div className="flex flex-col gap-6">
      <form onSubmit={handleSubmit}>
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">Acme Inc.</span>
            </a>
            <h1 className="text-xl font-bold">Welcome back to Acme Inc.</h1>
          </div>
          <div className="flex flex-col gap-5">
            <div className="grid gap-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                name="email"
                type="email"
                placeholder="hello@example.com"
                readOnly={isLoading}
                required
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                name="password"
                type="password"
                placeholder="Enter password here"
                readOnly={isLoading}
                required
              />
            </div>
            <Button type="submit" className="mt-2 w-full" size="lg" disabled={isLoading}>
              {isLoading && <LoaderIcon className="animate-spin" />}
              {isLoading ? "Logging in..." : "Login"}
            </Button>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <div className="grid gap-4 sm:grid-cols-2">
            <Button
              variant="outline"
              className="w-full"
              type="button"
              disabled={isLoading}
              onClick={() =>
                auth.signInWithOAuth(
                  {
                    provider: "github",
                    callbackURL: redirectUrl,
                  },
                  {
                    onRequest: () => {
                      setIsLoading(true);
                      setErrorMessage("");
                    },
                    onError: (ctx) => {
                      setIsLoading(false);
                      setErrorMessage(ctx.error.message);
                    },
                  },
                )
              }
            >
              <GitHubIcon />
              Login with GitHub
            </Button>
            <Button
              variant="outline"
              className="w-full"
              type="button"
              disabled={isLoading}
              onClick={() =>
                auth.signInWithOAuth(
                  {
                    provider: "google",
                    callbackURL: redirectUrl,
                  },
                  {
                    onRequest: () => {
                      setIsLoading(true);
                      setErrorMessage("");
                    },
                    onError: (ctx) => {
                      setIsLoading(false);
                      setErrorMessage(ctx.error.message);
                    },
                  },
                )
              }
            >
              <GoogleIcon />
              Login with Google
            </Button>
          </div>
        </div>
      </form>

      <div className="text-center text-sm">
        Don&apos;t have an account?{" "}
        <Link to="/signup" className="underline underline-offset-4">
          Sign up
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="src/features/auth/components/signup.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { Link, useNavigate, useRouteContext } from "@tanstack/react-router";
import { useState } from "react";
import { auth } from "~/lib/auth-client";
import { Button } from "~/shared/ui/button";
import { GitHubIcon, GoogleIcon, LoaderIcon, LogoIcon } from "~/shared/ui/icons";
import { Input } from "~/shared/ui/input";
import { Label } from "~/shared/ui/label";

export default function SignupForm() {
  const { redirectUrl } = useRouteContext({ from: "/(auth)/signup" });
  const queryClient = useQueryClient();
  const navigate = useNavigate();

  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (isLoading) return;

    const formData = new FormData(e.currentTarget);
    const name = formData.get("name") as string;
    const email = formData.get("email") as string;
    const password = formData.get("password") as string;
    const confirmPassword = formData.get("confirm_password") as string;

    if (!name || !email || !password || !confirmPassword) return;

    if (password !== confirmPassword) {
      setErrorMessage("Passwords do not match");
      return;
    }

    setIsLoading(true);
    setErrorMessage("");

    auth.signUp.email(
      {
        name,
        email,
        password,
        callbackURL: redirectUrl,
      },
      {
        onError: (ctx) => {
          setErrorMessage(ctx.error.message);
          setIsLoading(false);
        },
        onSuccess: async () => {
          await queryClient.invalidateQueries({ queryKey: ["user"] });
          navigate({ to: redirectUrl });
        },
      },
    );
  };

  return (
    <div className="flex flex-col gap-6">
      <form onSubmit={handleSubmit}>
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">Acme Inc.</span>
            </a>
            <h1 className="text-xl font-bold">Sign up for Acme Inc.</h1>
          </div>
          <div className="flex flex-col gap-5">
            <div className="grid gap-2">
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                name="name"
                type="text"
                placeholder="John Doe"
                readOnly={isLoading}
                required
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                name="email"
                type="email"
                placeholder="hello@example.com"
                readOnly={isLoading}
                required
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                name="password"
                type="password"
                placeholder="Password"
                readOnly={isLoading}
                required
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="confirm_password">Confirm Password</Label>
              <Input
                id="confirm_password"
                name="confirm_password"
                type="password"
                placeholder="Confirm Password"
                readOnly={isLoading}
                required
              />
            </div>
            <Button type="submit" className="mt-2 w-full" size="lg" disabled={isLoading}>
              {isLoading && <LoaderIcon className="animate-spin" />}
              {isLoading ? "Signing up..." : "Sign up"}
            </Button>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <div className="grid gap-4 sm:grid-cols-2">
            <Button
              variant="outline"
              className="w-full"
              type="button"
              disabled={isLoading}
              onClick={() =>
                auth.signInWithOAuth(
                  {
                    provider: "github",
                    callbackURL: redirectUrl,
                  },
                  {
                    onRequest: () => {
                      setIsLoading(true);
                      setErrorMessage("");
                    },
                    onError: (ctx) => {
                      setIsLoading(false);
                      setErrorMessage(ctx.error.message);
                    },
                  },
                )
              }
            >
              <GitHubIcon />
              Sign up with GitHub
            </Button>
            <Button
              variant="outline"
              className="w-full"
              type="button"
              disabled={isLoading}
              onClick={() =>
                auth.signInWithOAuth(
                  {
                    provider: "google",
                    callbackURL: redirectUrl,
                  },
                  {
                    onRequest: () => {
                      setIsLoading(true);
                      setErrorMessage("");
                    },
                    onError: (ctx) => {
                      setIsLoading(false);
                      setErrorMessage(ctx.error.message);
                    },
                  },
                )
              }
            >
              <GoogleIcon />
              Sign up with Google
            </Button>
          </div>
        </div>
      </form>

      <div className="text-center text-sm">
        Already have an account?{" "}
        <Link to="/login" className="underline underline-offset-4">
          Login
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="src/features/auth/useAuthGuard.tsx">
import { useNavigate } from "@tanstack/react-router";
import React, { useEffect } from "react";
import type { User } from "better-auth";

interface UseAuthGuardOptions {
  /**
   * The user object from the auth context/loader
   */
  user: User | null;
  
  /**
   * Whether authentication is required for this route
   * @default true
   */
  requireAuth?: boolean;
  
  /**
   * Whether to redirect authenticated users away (for login/signup pages)
   * @default false
   */
  redirectAuthenticated?: boolean;
  
  /**
   * URL to redirect to when authentication is required but user is not authenticated
   * @default "/login"
   */
  redirectTo?: string;
  
  /**
   * URL to redirect authenticated users to when redirectAuthenticated is true
   * @default "/dashboard"
   */
  authenticatedRedirectTo?: string;
  
  /**
   * Optional callback to execute after successful authentication check
   */
  onAuthSuccess?: (user: User) => void;
  
  /**
   * Optional callback to execute when authentication fails
   */
  onAuthFail?: () => void;
}

/**
 * Hook to handle authentication guards for routes
 * 
 * @example
 * // Require authentication
 * useAuthGuard({ user, requireAuth: true });
 * 
 * @example
 * // Redirect authenticated users away from login page
 * useAuthGuard({ user, redirectAuthenticated: true });
 * 
 * @example
 * // Custom redirects and callbacks
 * useAuthGuard({
 *   user,
 *   requireAuth: true,
 *   redirectTo: "/auth/signin",
 *   onAuthSuccess: (user) => console.log("Authenticated as", user.name)
 * });
 */
export function useAuthGuard({
  user,
  requireAuth = true,
  redirectAuthenticated = false,
  redirectTo = "/login",
  authenticatedRedirectTo = "/dashboard",
  onAuthSuccess,
  onAuthFail,
}: UseAuthGuardOptions) {
  const navigate = useNavigate();

  useEffect(() => {
    // Handle redirect for authenticated users (e.g., on login/signup pages)
    if (redirectAuthenticated && user) {
      navigate({ to: authenticatedRedirectTo, replace: true });
      return;
    }

    // Handle authentication requirement
    if (requireAuth && !user) {
      onAuthFail?.();
      navigate({ 
        to: redirectTo, 
        replace: true,
        search: (prev) => ({ 
          ...prev, 
          redirect: window.location.pathname 
        })
      });
      return;
    }

    // Authentication successful
    if (requireAuth && user) {
      onAuthSuccess?.(user);
    }
  }, [
    user, 
    requireAuth, 
    redirectAuthenticated, 
    redirectTo, 
    authenticatedRedirectTo, 
    navigate,
    onAuthSuccess,
    onAuthFail
  ]);

  return {
    isAuthenticated: !!user,
    isLoading: false, // Can be extended if using async auth state
    user,
  };
}

/**
 * Higher-order component to wrap components with auth guard
 * 
 * @example
 * export default withAuthGuard(DashboardComponent, { requireAuth: true });
 */
export function withAuthGuard<P extends { user: User | null }>(
  Component: React.ComponentType<P>,
  options: Omit<UseAuthGuardOptions, "user">
) {
  return function AuthGuardedComponent(props: P) {
    useAuthGuard({ ...options, user: props.user });
    return <Component {...props} />;
  };
}
</file>

<file path="src/lib/auth/middleware/__tests__/auth-guard.test.ts">
import { describe, expect, it, vi, beforeEach } from 'vitest'

describe('authMiddleware', () => {
  // Since the authMiddleware uses TanStack Start's createMiddleware which is complex to test,
  // we'll focus on testing the authentication logic separately
  
  it('should be defined', async () => {
    const { authMiddleware } = await import('../auth-guard')
    expect(authMiddleware).toBeDefined()
    expect(typeof authMiddleware.server).toBe('function')
  })

  describe('authentication logic', () => {
    // Mock functions for testing the auth logic
    const mockGetSession = vi.fn()
    
    beforeEach(() => {
      vi.clearAllMocks()
    })

    it('should allow access when session exists', async () => {
      const mockUser = {
        id: 'test-user-id',
        email: 'test@example.com',
        name: 'Test User',
      }
      
      const mockSession = {
        user: mockUser,
        session: { id: 'test-session-id' },
      }
      
      mockGetSession.mockResolvedValueOnce(mockSession)
      
      // Test the authentication logic
      const headers = new Headers({ cookie: 'session=test' })
      const result = await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      })
      
      expect(result).toEqual(mockSession)
      expect(result.user).toEqual(mockUser)
    })

    it('should deny access when no session exists', async () => {
      mockGetSession.mockResolvedValueOnce(null)
      
      // Test the authentication logic
      const headers = new Headers({ cookie: 'session=invalid' })
      const result = await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      })
      
      expect(result).toBeNull()
      
      // In the actual middleware, this would trigger:
      // - setResponseStatus(401)
      // - throw new Error('Unauthorized')
    })

    it('should pass correct parameters to getSession', async () => {
      const headers = new Headers({
        cookie: 'session=test-session',
        authorization: 'Bearer token',
      })
      
      mockGetSession.mockResolvedValueOnce({ user: {}, session: {} })
      
      await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      })
      
      expect(mockGetSession).toHaveBeenCalledWith({
        headers,
        query: { disableCookieCache: true },
      })
    })

    it('should always disable cookie cache for fresh session check', async () => {
      const headers = new Headers({ cookie: 'session=test' })
      
      mockGetSession.mockResolvedValueOnce({ user: {}, session: {} })
      
      await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      })
      
      const call = mockGetSession.mock.calls[0][0]
      expect(call.query.disableCookieCache).toBe(true)
    })
  })
})
</file>

<file path="src/lib/security/middleware/rate-limit.ts">
import { serverOnly } from "@tanstack/react-start";
import { securityConfig } from "../config";

interface RateLimitStore {
  [key: string]: {
    count: number;
    resetTime: number;
  };
}

// In-memory store for rate limiting (consider using Redis in production)
const rateLimitStore: RateLimitStore = {};

/**
 * Rate limiting middleware
 * @param type - Type of rate limit to apply ('auth' or 'api')
 * @param key - Unique key for the rate limit (e.g., IP address, user ID)
 */
export const rateLimit = serverOnly((type: keyof typeof securityConfig.rateLimit, key: string) => {
  const config = securityConfig.rateLimit[type];
  const now = Date.now();
  
  // Clean up expired entries
  Object.keys(rateLimitStore).forEach((k) => {
    if (rateLimitStore[k].resetTime < now) {
      delete rateLimitStore[k];
    }
  });
  
  const limitKey = `${type}:${key}`;
  const record = rateLimitStore[limitKey];
  
  if (!record || record.resetTime < now) {
    // Create new record
    rateLimitStore[limitKey] = {
      count: 1,
      resetTime: now + config.windowMs,
    };
    return { allowed: true, remaining: config.max - 1 };
  }
  
  if (record.count >= config.max) {
    // Rate limit exceeded
    const error = Object.assign(new Error(config.message), {
      status: 429,
      retryAfter: Math.ceil((record.resetTime - now) / 1000)
    });
    throw error;
  }
  
  // Increment count
  record.count++;
  
  return {
    allowed: true,
    remaining: config.max - record.count,
  };
});

/**
 * Extract client IP from request headers
 */
export const getClientIp = serverOnly((headers: Headers): string => {
  // Check various headers that might contain the real IP
  const forwardedFor = headers.get("x-forwarded-for");
  if (forwardedFor) {
    return forwardedFor.split(",")[0].trim();
  }
  
  const realIp = headers.get("x-real-ip");
  if (realIp) {
    return realIp;
  }
  
  const cfConnectingIp = headers.get("cf-connecting-ip");
  if (cfConnectingIp) {
    return cfConnectingIp;
  }
  
  // Default to a placeholder if no IP found
  return "unknown";
});
</file>

<file path="src/lib/security/utils/password-validator.ts">
import { securityConfig } from "../config";

interface PasswordValidationResult {
  isValid: boolean;
  errors: string[];
}

/**
 * Validates a password against security requirements
 */
export function validatePassword(password: string): PasswordValidationResult {
  const errors: string[] = [];
  const config = securityConfig.password;
  
  // Check minimum length
  if (password.length < config.minLength) {
    errors.push(`Password must be at least ${config.minLength} characters long`);
  }
  
  // Check uppercase requirement
  if (config.requireUppercase && !/[A-Z]/.test(password)) {
    errors.push("Password must contain at least one uppercase letter");
  }
  
  // Check lowercase requirement
  if (config.requireLowercase && !/[a-z]/.test(password)) {
    errors.push("Password must contain at least one lowercase letter");
  }
  
  // Check numbers requirement
  if (config.requireNumbers && !/\d/.test(password)) {
    errors.push("Password must contain at least one number");
  }
  
  // Check special characters requirement
  if (config.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push("Password must contain at least one special character");
  }
  
  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * Generates a password strength score (0-5)
 */
export function getPasswordStrength(password: string): number {
  let strength = 0;
  
  // Length bonuses
  if (password.length >= 8) strength++;
  if (password.length >= 12) strength++;
  if (password.length >= 16) strength++;
  
  // Complexity bonuses
  if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
  if (/\d/.test(password)) strength++;
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) strength++;
  
  // Cap at 5
  return Math.min(strength, 5);
}

/**
 * Get a human-readable password strength label
 */
export function getPasswordStrengthLabel(strength: number): string {
  switch (strength) {
    case 0:
    case 1:
      return "Very Weak";
    case 2:
      return "Weak";
    case 3:
      return "Fair";
    case 4:
      return "Strong";
    case 5:
      return "Very Strong";
    default:
      return "Unknown";
  }
}
</file>

<file path="src/lib/security/config.ts">
/**
 * Security configuration for the application
 * Centralizes all security-related settings
 */

export const securityConfig = {
  // Cookie settings for Better Auth
  cookies: {
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax" as const,
    httpOnly: true,
    path: "/",
    // Set domain only in production
    ...(process.env.NODE_ENV === "production" && process.env.COOKIE_DOMAIN
      ? { domain: process.env.COOKIE_DOMAIN }
      : {}),
  },
  
  // Session configuration
  session: {
    // 7 days in seconds
    maxAge: 7 * 24 * 60 * 60,
    // Update session if it expires in less than 1 day
    updateAge: 24 * 60 * 60,
    // Enable cookie caching for performance
    cookieCache: {
      enabled: true,
      maxAge: 5 * 60, // 5 minutes
    },
  },
  
  // CORS configuration
  cors: {
    origin: process.env.VITE_BASE_URL || "http://localhost:5173",
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  },
  
  // Rate limiting configuration
  rateLimit: {
    // Auth endpoints
    auth: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 5, // 5 requests per window
      message: "Too many authentication attempts, please try again later.",
    },
    // API endpoints
    api: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // 100 requests per window
      message: "Too many requests, please try again later.",
    },
  },
  
  // Password requirements
  password: {
    minLength: 8,
    requireUppercase: true,
    requireLowercase: true,
    requireNumbers: true,
    requireSpecialChars: true,
  },
  
  // OAuth providers allowed domains
  oauth: {
    allowedDomains: process.env.OAUTH_ALLOWED_DOMAINS?.split(",") || [],
  },
} as const;

// Type exports
export type SecurityConfig = typeof securityConfig;
export type CookieConfig = typeof securityConfig.cookies;
export type SessionConfig = typeof securityConfig.session;
</file>

<file path="src/lib/security/index.ts">
/**
 * Security module exports
 * Centralizes all security-related functionality
 */

export { securityConfig } from "./config";
export type { SecurityConfig, CookieConfig, SessionConfig } from "./config";

export { rateLimit, getClientIp } from "./middleware/rate-limit";

export { 
  validatePassword, 
  getPasswordStrength, 
  getPasswordStrengthLabel 
} from "./utils/password-validator";
</file>

<file path="src/lib/server/__tests__/example.test.ts">
import { describe, expect, it } from 'vitest'

// Example of a simple unit test for server-side functions
describe('Server Function Example', () => {
  // Helper function to test
  function calculateLeagueStats(teams: { wins: number; losses: number }[]) {
    const totalGames = teams.reduce((sum, team) => sum + team.wins + team.losses, 0)
    const totalWins = teams.reduce((sum, team) => sum + team.wins, 0)
    const avgWinRate = teams.length > 0 ? totalWins / totalGames : 0
    
    return {
      totalTeams: teams.length,
      totalGames: totalGames / 2, // Each game has 2 teams
      avgWinRate: Math.round(avgWinRate * 100) / 100,
    }
  }

  it('calculates league statistics correctly', () => {
    const teams = [
      { wins: 10, losses: 5 },
      { wins: 8, losses: 7 },
      { wins: 12, losses: 3 },
      { wins: 5, losses: 10 },
    ]

    const stats = calculateLeagueStats(teams)

    expect(stats).toEqual({
      totalTeams: 4,
      totalGames: 30, // (10+5+8+7+12+3+5+10) / 2
      avgWinRate: 0.58, // 35 wins / 60 total
    })
  })

  it('handles empty team array', () => {
    const stats = calculateLeagueStats([])

    expect(stats).toEqual({
      totalTeams: 0,
      totalGames: 0,
      avgWinRate: 0,
    })
  })

  it('handles single team', () => {
    const teams = [{ wins: 5, losses: 3 }]
    const stats = calculateLeagueStats(teams)

    expect(stats).toEqual({
      totalTeams: 1,
      totalGames: 4, // (5+3) / 2
      avgWinRate: 0.63, // 5 / 8
    })
  })
})
</file>

<file path="src/lib/env.ts">
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import dotenvExpand from 'dotenv-expand';

/**
 * Environment configuration loader with support for layered config files
 * Priority order (highest to lowest):
 * 1. Process environment variables
 * 2. .env.{NODE_ENV}.local
 * 3. .env.local (except in test)
 * 4. .env.{NODE_ENV}
 * 5. .env
 */

export interface EnvConfig {
  DATABASE_URL: string;
  DATABASE_URL_UNPOOLED?: string;  // Direct connection URL (for migrations)
  DATABASE_POOLED_URL?: string;     // Explicit pooled URL override
  DATABASE_UNPOOLED_URL?: string;   // Explicit unpooled URL override
  NETLIFY_DATABASE_URL?: string;
  NETLIFY_DATABASE_URL_UNPOOLED?: string;
  VITE_BASE_URL: string;
  GITHUB_CLIENT_ID?: string;
  GITHUB_CLIENT_SECRET?: string;
  GOOGLE_CLIENT_ID?: string;
  GOOGLE_CLIENT_SECRET?: string;
  BETTER_AUTH_SECRET?: string;
  VITE_ENABLE_ANALYTICS?: string;
  VITE_ENABLE_SENTRY?: string;
  VITE_POSTHOG_KEY?: string;
  VITE_SENTRY_DSN?: string;
  NODE_ENV?: string;
  NETLIFY?: string;
  VERCEL_ENV?: string;
}

class EnvironmentLoader {
  private config: Partial<EnvConfig> = {};
  private loaded = false;

  constructor() {
    this.load();
  }

  private parseEnvFile(filePath: string): Record<string, string> {
    if (!existsSync(filePath)) {
      return {};
    }

    try {
      const content = readFileSync(filePath, 'utf-8');
      const parsed: Record<string, string> = {};

      content.split('\n').forEach(line => {
        // Skip comments and empty lines
        if (line.trim().startsWith('#') || !line.trim()) {
          return;
        }

        const [key, ...valueParts] = line.split('=');
        if (key && valueParts.length > 0) {
          const value = valueParts.join('=').trim();
          // Remove quotes if present
          parsed[key.trim()] = value.replace(/^["']|["']$/g, '');
        }
      });

      return parsed;
    } catch (error) {
      console.warn(`Failed to parse env file ${filePath}:`, error);
      return {};
    }
  }

  private load() {
    if (this.loaded) return;

    const nodeEnv = process.env.NODE_ENV || 'development';
    const cwd = process.cwd();

    // Load in priority order (lowest to highest)
    const envFiles = [
      '.env',
      `.env.${nodeEnv}`,
      nodeEnv !== 'test' && '.env.local',
      `.env.${nodeEnv}.local`
    ].filter(Boolean) as string[];

    // Load each file and merge
    const combinedEnv: Record<string, string> = {};
    
    for (const file of envFiles) {
      const filePath = join(cwd, file);
      const parsed = this.parseEnvFile(filePath);
      Object.assign(combinedEnv, parsed);
    }

    // Apply environment variable expansion
    const expanded = dotenvExpand.expand({ 
      parsed: combinedEnv, 
      processEnv: {} 
    });

    if (expanded.parsed) {
      this.config = expanded.parsed as Partial<EnvConfig>;
    }

    // Override with actual process.env values
    Object.keys(process.env).forEach(key => {
      if (process.env[key] !== undefined) {
        this.config[key as keyof EnvConfig] = process.env[key];
      }
    });

    this.loaded = true;
  }

  get<K extends keyof EnvConfig>(key: K): EnvConfig[K] | undefined {
    return this.config[key];
  }

  getRequired<K extends keyof EnvConfig>(key: K): EnvConfig[K] {
    const value = this.get(key);
    if (value === undefined) {
      throw new Error(`Required environment variable ${String(key)} is not set`);
    }
    return value;
  }

  getAll(): Partial<EnvConfig> {
    return { ...this.config };
  }

  isDevelopment(): boolean {
    const env = this.get('NODE_ENV') || 'development';
    return env === 'development';
  }

  isProduction(): boolean {
    return this.get('NODE_ENV') === 'production';
  }

  isTest(): boolean {
    return this.get('NODE_ENV') === 'test';
  }
}

// Export singleton instance
export const env = new EnvironmentLoader();

// Helper functions for common use cases
export const getDbUrl = () => env.getRequired('DATABASE_URL');

/**
 * Get the pooled database URL for serverless functions.
 * Priority: DATABASE_POOLED_URL > NETLIFY_DATABASE_URL > DATABASE_URL
 */
export const getPooledDbUrl = () => 
  env.get('DATABASE_POOLED_URL') || 
  env.get('NETLIFY_DATABASE_URL') || 
  env.getRequired('DATABASE_URL');

/**
 * Get the unpooled database URL for migrations and long operations.
 * Priority: DATABASE_UNPOOLED_URL > DATABASE_URL_UNPOOLED > NETLIFY_DATABASE_URL_UNPOOLED > DATABASE_URL
 */
export const getUnpooledDbUrl = () => 
  env.get('DATABASE_UNPOOLED_URL') || 
  env.get('DATABASE_URL_UNPOOLED') ||
  env.get('NETLIFY_DATABASE_URL_UNPOOLED') || 
  env.getRequired('DATABASE_URL');
export const getBaseUrl = () => env.getRequired('VITE_BASE_URL');
export const getAuthSecret = () => env.get('BETTER_AUTH_SECRET') || 'dev-secret-change-in-production';

// Feature flags
export const isAnalyticsEnabled = () => env.get('VITE_ENABLE_ANALYTICS') === 'true';
export const isSentryEnabled = () => env.get('VITE_ENABLE_SENTRY') === 'true';
export const isServerless = () => !!(env.get('NETLIFY') || env.get('VERCEL_ENV'));
</file>

<file path="src/routes/api/auth/login.example.ts">
import { json } from "@tanstack/react-start";
import { rateLimit, getClientIp } from "~/lib/security";
import { auth } from "~/lib/auth";

/**
 * Example of how to implement rate limiting in an auth endpoint
 * This is a reference implementation - adapt to your specific needs
 */
export const APIRoute = {
  POST: async ({ request }: { request: Request }) => {
    try {
      // Apply rate limiting based on client IP
      const clientIp = getClientIp(request.headers);
      await rateLimit("auth", clientIp);
      
      // Parse request body
      const body = await request.json();
      const { email, password } = body;
      
      // Perform authentication
      const session = await auth.api.signInEmail({
        body: { email, password },
        asResponse: true,
      });
      
      // Return response
      return session;
    } catch (error) {
      // Handle rate limit errors
      if (error instanceof Error && error.message.includes("Too many")) {
        return json(
          { error: error.message },
          { 
            status: 429,
            headers: {
              "Retry-After": "900", // 15 minutes in seconds
            },
          }
        );
      }
      
      // Handle other errors
      return json(
        { error: "Authentication failed" },
        { status: 401 }
      );
    }
  },
};
</file>

<file path="src/shared/hooks/useTheme.ts">
import { useCallback, useEffect, useLayoutEffect, useState } from "react";

export type Theme = "light" | "dark" | "system";

// Use useLayoutEffect on client, useEffect on server
const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

export function useTheme() {
  // Initialize theme from localStorage using lazy state initialization
  const [theme, setTheme] = useState<Theme>(() => {
    if (typeof window !== "undefined") {
      const storedTheme = localStorage.getItem("theme");
      if (storedTheme === "light" || storedTheme === "dark" || storedTheme === "system") {
        return storedTheme as Theme;
      }
    }
    return "system";
  });

  const [resolvedTheme, setResolvedTheme] = useState<"light" | "dark">(() => {
    if (typeof window !== "undefined") {
      if (theme === "system") {
        return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      }
      return theme === "dark" ? "dark" : "light";
    }
    return "light";
  });

  // Apply theme changes
  useIsomorphicLayoutEffect(() => {
    const root = document.documentElement;
    
    if (theme === "system") {
      const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
      
      const updateTheme = () => {
        const isDark = mediaQuery.matches;
        root.classList.toggle("dark", isDark);
        setResolvedTheme(isDark ? "dark" : "light");
      };
      
      // Initial update
      updateTheme();
      
      // Listen for changes
      mediaQuery.addEventListener("change", updateTheme);
      
      return () => {
        mediaQuery.removeEventListener("change", updateTheme);
      };
    } else {
      const isDark = theme === "dark";
      root.classList.toggle("dark", isDark);
      setResolvedTheme(isDark ? "dark" : "light");
    }
  }, [theme]);

  // Persist theme preference
  useEffect(() => {
    if (theme !== "system") {
      localStorage.setItem("theme", theme);
    } else {
      localStorage.removeItem("theme");
    }
  }, [theme]);

  const setThemeAndPersist = useCallback((newTheme: Theme) => {
    setTheme(newTheme);
  }, []);

  const toggleTheme = useCallback(() => {
    setTheme((prevTheme) => {
      if (prevTheme === "light") return "dark";
      if (prevTheme === "dark") return "light";
      // If system, toggle to the opposite of current resolved theme
      return resolvedTheme === "dark" ? "light" : "dark";
    });
  }, [resolvedTheme]);

  return {
    theme,
    setTheme: setThemeAndPersist,
    resolvedTheme,
    toggleTheme,
  };
}
</file>

<file path="src/shared/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/shared/ui/__tests__/button.test.tsx">
import { describe, expect, it, vi } from 'vitest'
import { render, screen } from '~/tests/utils'
import userEvent from '@testing-library/user-event'
import { Button } from '../button'

describe('Button', () => {
  it('renders children correctly', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument()
  })

  it('applies default variant and size classes', () => {
    render(<Button>Default Button</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('bg-primary', 'text-primary-foreground', 'h-9', 'px-4')
  })

  it('applies custom variant classes', () => {
    render(<Button variant="destructive">Delete</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('bg-destructive', 'text-white')
  })

  it('applies custom size classes', () => {
    render(<Button size="sm">Small Button</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('h-8', 'px-3')
  })

  it('handles click events', async () => {
    const handleClick = vi.fn()
    const user = userEvent.setup()
    
    render(<Button onClick={handleClick}>Click me</Button>)
    const button = screen.getByRole('button')
    
    await user.click(button)
    expect(handleClick).toHaveBeenCalledTimes(1)
  })

  it('respects disabled state', async () => {
    const handleClick = vi.fn()
    const user = userEvent.setup()
    
    render(<Button disabled onClick={handleClick}>Disabled</Button>)
    const button = screen.getByRole('button')
    
    expect(button).toBeDisabled()
    expect(button).toHaveClass('disabled:opacity-50')
    
    await user.click(button)
    expect(handleClick).not.toHaveBeenCalled()
  })

  it('renders as a custom component when asChild is true', () => {
    render(
      <Button asChild>
        <a href="/link">Link Button</a>
      </Button>
    )
    
    const link = screen.getByRole('link', { name: 'Link Button' })
    expect(link).toBeInTheDocument()
    expect(link).toHaveAttribute('href', '/link')
    expect(link).toHaveClass('bg-primary')
  })

  it('applies custom className', () => {
    render(<Button className="custom-class">Custom</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('custom-class')
  })

  it('forwards additional props', () => {
    render(<Button data-testid="custom-button" type="submit">Submit</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveAttribute('data-testid', 'custom-button')
    expect(button).toHaveAttribute('type', 'submit')
  })
})
</file>

<file path="src/shared/ui/button.tsx">
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };
</file>

<file path="src/shared/ui/icons.tsx">
import type { SVGProps } from "react";

export function GitHubIcon(props: SVGProps<SVGSVGElement>) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" {...props}>
      <path
        d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"
        fill="currentColor"
      />
    </svg>
  );
}

export function GoogleIcon(props: SVGProps<SVGSVGElement>) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" {...props}>
      <path
        d="M12.48 10.92v3.28h7.84c-.24 1.84-.853 3.187-1.787 4.133-1.147 1.147-2.933 2.4-6.053 2.4-4.827 0-8.6-3.893-8.6-8.72s3.773-8.72 8.6-8.72c2.6 0 4.507 1.027 5.907 2.347l2.307-2.307C18.747 1.44 16.133 0 12.48 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z"
        fill="currentColor"
      />
    </svg>
  );
}

// Re-export commonly used Lucide icons for consistency
export {
  GalleryVerticalEnd as LogoIcon,
  LoaderCircle as LoaderIcon,
  MoonIcon,
  SunIcon,
} from "lucide-react";
</file>

<file path="src/shared/ui/input.tsx">
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className,
      )}
      {...props}
    />
  );
}

export { Input };
</file>

<file path="src/shared/ui/label.tsx">
import * as LabelPrimitive from "@radix-ui/react-label";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className,
      )}
      {...props}
    />
  );
}

export { Label };
</file>

<file path="src/tests/mocks/auth.ts">
import { vi } from 'vitest'

// Define types inline since better-auth doesn't export them directly
export interface User {
  id: string;
  email: string;
  name: string;
  emailVerified: boolean;
  image: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface Session {
  id: string;
  userId: string;
  expiresAt: Date;
  ipAddress: string;
  userAgent: string;
  createdAt: Date;
  updatedAt: Date;
}

export const mockUser: User = {
  id: 'test-user-id',
  email: 'test@example.com',
  name: 'Test User',
  emailVerified: true,
  image: null,
  createdAt: new Date('2024-01-01'),
  updatedAt: new Date('2024-01-01'),
}

export const mockSession: Session = {
  id: 'test-session-id',
  userId: mockUser.id,
  expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24), // 24 hours from now
  ipAddress: '127.0.0.1',
  userAgent: 'test-agent',
  createdAt: new Date('2024-01-01'),
  updatedAt: new Date('2024-01-01'),
}

export const createAuthMocks = () => {
  const authClient = {
    signIn: {
      email: vi.fn().mockResolvedValue({ 
        data: { user: mockUser, session: mockSession },
        error: null 
      }),
    },
    signUp: {
      email: vi.fn().mockResolvedValue({ 
        data: { user: mockUser, session: mockSession },
        error: null 
      }),
    },
    signOut: vi.fn().mockResolvedValue({ error: null }),
    getSession: vi.fn().mockResolvedValue({ 
      data: { user: mockUser, session: mockSession },
      error: null 
    }),
  }

  return { authClient, mockUser, mockSession }
}
</file>

<file path="src/tests/README.md">
# Testing Guide

This directory contains the testing infrastructure for Solstice, using Vitest as the test runner.

## Running Tests

```bash
# Run all tests once
pnpm test

# Run tests in watch mode
pnpm test:watch

# Run tests with UI
pnpm test:ui

# Run tests with coverage
pnpm test:coverage
```

## Test Structure

- `setup.ts` - Global test setup and configuration
- `utils.tsx` - Common test utilities and custom render functions
- `mocks/` - Shared mocks for testing

## Writing Tests

### Component Tests

Use the custom `render` function from `~/tests/utils` which includes providers:

```tsx
import { render, screen } from '~/tests/utils'
import { Button } from '~/shared/ui/button'

describe('Button', () => {
  it('renders correctly', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByRole('button')).toHaveText('Click me')
  })
})
```

### Testing with Auth

Use the auth mocks for testing authenticated features:

```tsx
import { createAuthMocks } from '~/tests/mocks/auth'

const { mockUser, mockSession } = createAuthMocks()
```

### Server Function Tests

Test server-side logic in isolation:

```ts
import { describe, it, expect } from 'vitest'

describe('Server Function', () => {
  it('processes data correctly', () => {
    const result = myServerFunction(input)
    expect(result).toEqual(expected)
  })
})
```

## Test Environment

- Environment: jsdom (for browser-like testing)
- Test framework: Vitest
- Testing libraries: @testing-library/react, @testing-library/user-event
- Assertion library: @testing-library/jest-dom

## Coverage

Coverage reports are generated in the `coverage/` directory. View the HTML report by opening `coverage/index.html` in your browser.

## Best Practices

1. **Isolation**: Each test should be independent and not rely on other tests
2. **Mocking**: Mock external dependencies and API calls
3. **User-centric**: Test from the user's perspective using Testing Library queries
4. **Async handling**: Use `waitFor` for async operations
5. **Cleanup**: Tests automatically cleanup after each test via the setup file
</file>

<file path="src/tests/setup.ts">
import '@testing-library/jest-dom'
import { cleanup } from '@testing-library/react'
import { afterEach, vi } from 'vitest'

// Cleanup after each test case
afterEach(() => {
  cleanup()
})

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(), // deprecated
    removeListener: vi.fn(), // deprecated
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))

// Mock ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))
</file>

<file path="src/tests/utils.tsx">
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { render, RenderOptions } from '@testing-library/react'
import { ReactElement, ReactNode } from 'react'

// Create a custom render function that includes providers
export function createTestQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
        staleTime: 0,
      },
      mutations: {
        retry: false,
      },
    },
  })
}

interface AllTheProvidersProps {
  children: ReactNode
}

export function AllTheProviders({ children }: AllTheProvidersProps) {
  const queryClient = createTestQueryClient()
  
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}

export function renderWithProviders(
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) {
  return render(ui, { wrapper: AllTheProviders, ...options })
}

// Re-export everything from @testing-library/react
export * from '@testing-library/react'
export { renderWithProviders as render }
</file>

<file path=".editorconfig">
root = true

[*]
end_of_line = lf
insert_final_newline = true
indent_style = space
indent_size = 2
charset = utf-8
trim_trailing_whitespace = true
max_line_length = 90
</file>

<file path=".env.production">
# Production Environment Variables
# This file contains default values for production
# Actual production secrets should be set in Netlify dashboard

# Database
# DATABASE_URL should be set in Netlify environment variables

# Application
VITE_BASE_URL=https://solstice.app

# OAuth Providers
# GITHUB_CLIENT_ID should be set in Netlify environment variables
# GITHUB_CLIENT_SECRET should be set in Netlify environment variables
# GOOGLE_CLIENT_ID should be set in Netlify environment variables  
# GOOGLE_CLIENT_SECRET should be set in Netlify environment variables

# Better Auth
# BETTER_AUTH_SECRET should be set in Netlify environment variables

# Feature Flags
VITE_ENABLE_ANALYTICS=true
VITE_ENABLE_SENTRY=true

# API Keys
# VITE_POSTHOG_KEY should be set in Netlify environment variables
# VITE_SENTRY_DSN should be set in Netlify environment variables

# Environment
NODE_ENV=production
</file>

<file path=".env.test">
# Test Environment Variables
# This file contains environment variables used specifically for testing

# Database (use a test database or in-memory database)
DATABASE_URL="postgresql://test:test@localhost:5432/solstice_test"

# Application
VITE_BASE_URL="http://localhost:3000"

# OAuth Providers (use test credentials)
GITHUB_CLIENT_ID="test_github_client_id"
GITHUB_CLIENT_SECRET="test_github_client_secret"
GOOGLE_CLIENT_ID="test_google_client_id"
GOOGLE_CLIENT_SECRET="test_google_client_secret"

# Better Auth Secret (test secret)
BETTER_AUTH_SECRET="test-secret-key-for-testing-only"

# Node Environment
NODE_ENV="test"
</file>

<file path=".gitattributes">
* text=auto eol=lf
</file>

<file path="README.env.md">
# Environment Configuration

This project uses a layered environment configuration system that supports different environments (development, test, production) with proper secret management.

## Environment Files

The following environment files are supported (loaded in priority order):

1. `.env` - Base configuration shared across all environments
2. `.env.{NODE_ENV}` - Environment-specific configuration (e.g., `.env.test`, `.env.production`)
3. `.env.local` - Local overrides (not loaded in test environment)
4. `.env.{NODE_ENV}.local` - Local environment-specific overrides

Files are loaded in order, with later files overriding earlier ones. Process environment variables have the highest priority.

## Setup

1. Copy `.env.example` to `.env.local`:
   ```bash
   cp .env.example .env.local
   ```

2. Update `.env.local` with your local development values

3. For production deployment on Netlify, set sensitive environment variables in the Netlify dashboard

## Available Environment Variables

- `DATABASE_URL` - PostgreSQL connection string
- `VITE_BASE_URL` - Application base URL
- `GITHUB_CLIENT_ID` - GitHub OAuth client ID
- `GITHUB_CLIENT_SECRET` - GitHub OAuth client secret
- `GOOGLE_CLIENT_ID` - Google OAuth client ID
- `GOOGLE_CLIENT_SECRET` - Google OAuth client secret
- `BETTER_AUTH_SECRET` - Secret for Better Auth sessions
- `VITE_ENABLE_ANALYTICS` - Enable analytics (true/false)
- `VITE_ENABLE_SENTRY` - Enable Sentry error tracking (true/false)
- `VITE_POSTHOG_KEY` - PostHog analytics key
- `VITE_SENTRY_DSN` - Sentry DSN for error tracking

## Using Environment Variables in Code

```typescript
import { env, getDbUrl, getBaseUrl, isAnalyticsEnabled } from '@/lib/env';

// Get required variables (throws if not set)
const dbUrl = getDbUrl();
const baseUrl = getBaseUrl();

// Get optional variables
const githubClientId = env.get('GITHUB_CLIENT_ID');

// Check environment
if (env.isProduction()) {
  // Production-specific code
}

// Check feature flags
if (isAnalyticsEnabled()) {
  // Initialize analytics
}
```

## Netlify Deployment

The `netlify.toml` file is configured to set the appropriate `NODE_ENV` for different deployment contexts:

- **Production** (main branch): `NODE_ENV=production`
- **Branch deploys**: `NODE_ENV=test`
- **Deploy previews** (PRs): `NODE_ENV=test`

This ensures the correct environment files are loaded for each deployment type.
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import tsconfigPaths from 'vite-tsconfig-paths'
import { loadEnv } from 'vite'

export default defineConfig(({ mode }) => {
  // Load test environment variables
  const env = loadEnv(mode, process.cwd(), '')
  
  return {
    plugins: [react(), tsconfigPaths()],
    test: {
      environment: 'jsdom',
      globals: true,
      setupFiles: ['./src/tests/setup.ts'],
      include: ['src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
      exclude: ['node_modules', 'dist', '.next', '.cache', 'build'],
      coverage: {
        reporter: ['text', 'json', 'html'],
        exclude: [
          'node_modules/',
          'src/tests/',
          '**/*.d.ts',
          '**/*.config.*',
          '**/mockData.ts',
          'src/routeTree.gen.ts',
        ],
      },
      env: {
        ...env,
        // Override with test-specific env vars if needed
        VITE_BASE_URL: 'http://localhost:3000',
      },
    },
    resolve: {
      alias: {
        '~': '/src',
      },
    },
  }
})
</file>

<file path=".nitro/types/nitro-config.d.ts">
// Generated by nitro

// App Config
import type { Defu } from 'defu'



type UserAppConfig = Defu<{}, []>

declare module "nitropack/types" {
  interface AppConfig extends UserAppConfig {}
  interface NitroRuntimeConfig {

  }
}
export {}
</file>

<file path=".nitro/types/nitro-imports.d.ts">
export {}
</file>

<file path=".nitro/types/nitro-routes.d.ts">
// Generated by nitro
import type { Serialize, Simplify } from "nitropack/types";
declare module "nitropack/types" {
  type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T
  interface InternalApi {
  }
}
export {}
</file>

<file path=".nitro/types/nitro.d.ts">
/// <reference path="./nitro-routes.d.ts" />
/// <reference path="./nitro-config.d.ts" />
/// <reference path="./nitro-imports.d.ts" />
</file>

<file path="src/components/DefaultCatchBoundary.tsx">
import {
  ErrorComponent,
  type ErrorComponentProps,
  Link,
  rootRouteId,
  useMatch,
  useRouter,
} from "@tanstack/react-router";
import { Button } from "~/shared/ui/button";

export function DefaultCatchBoundary({ error }: Readonly<ErrorComponentProps>) {
  const router = useRouter();
  const isRoot = useMatch({
    strict: false,
    select: (state) => state.id === rootRouteId,
  });

  console.error(error);

  return (
    <div className="flex min-w-0 flex-1 flex-col items-center justify-center gap-6 p-4">
      <ErrorComponent error={error} />
      <div className="flex flex-wrap items-center gap-2">
        <Button
          type="button"
          onClick={() => {
            router.invalidate();
          }}
        >
          Try Again
        </Button>
        {isRoot ? (
          <Button asChild variant="secondary">
            <Link to="/">Home</Link>
          </Button>
        ) : (
          <Button asChild variant="secondary">
            <Link
              to="/"
              onClick={(e) => {
                e.preventDefault();
                window.history.back();
              }}
            >
              Go Back
            </Link>
          </Button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/NotFound.tsx">
import { Link } from "@tanstack/react-router";
import { Button } from "~/shared/ui/button";

export function NotFound() {
  return (
    <div className="space-y-2 p-2">
      <p>The page you are looking for does not exist.</p>
      <p className="flex flex-wrap items-center gap-2">
        <Button type="button" onClick={() => window.history.back()}>
          Go back
        </Button>
        <Button asChild variant="secondary">
          <Link to="/">Home</Link>
        </Button>
      </p>
    </div>
  );
}
</file>

<file path="src/lib/auth/functions/getUser.ts">
import { createServerFn } from "@tanstack/react-start";
import { getWebRequest } from "@tanstack/react-start/server";
import { auth } from "~/lib/auth";

export const getUser = createServerFn({ method: "GET" }).handler(async () => {
  const { headers } = getWebRequest();
  const session = await auth.api.getSession({ headers });

  return session?.user || null;
});
</file>

<file path="src/lib/auth/middleware/auth-guard.ts">
import { createMiddleware } from "@tanstack/react-start";
import { getWebRequest, setResponseStatus } from "@tanstack/react-start/server";
import { auth } from "~/lib/auth";

// https://tanstack.com/start/latest/docs/framework/react/middleware
// This is a sample middleware that you can use in your server functions.

/**
 * Middleware to force authentication on a server function, and add the user to the context.
 */
export const authMiddleware = createMiddleware({ type: "function" }).server(
  async ({ next }) => {
    const { headers } = getWebRequest();

    const session = await auth.api.getSession({
      headers,
      query: {
        // ensure session is fresh
        // https://www.better-auth.com/docs/concepts/session-management#session-caching
        disableCookieCache: true,
      },
    });

    if (!session) {
      setResponseStatus(401);
      throw new Error("Unauthorized");
    }

    return next({ context: { user: session.user } });
  },
);
</file>

<file path="src/lib/auth/auth-client.ts">
import { createAuthClient } from "better-auth/react";

// Create auth client instance
const authClient = createAuthClient({
  baseURL: import.meta.env.VITE_BASE_URL,
});

// Export a facade with all auth methods
export const auth = {
  // Authentication methods
  signIn: authClient.signIn,
  signUp: authClient.signUp,
  signOut: authClient.signOut,
  
  // OAuth methods
  signInWithOAuth: authClient.signIn.social,
  
  // Session methods
  getSession: authClient.getSession,
  useSession: authClient.useSession,
  
  // User methods  
  updateUser: authClient.updateUser,
  deleteUser: authClient.deleteUser,
  
  // Password methods
  forgetPassword: authClient.forgetPassword,
  resetPassword: authClient.resetPassword,
  changePassword: authClient.changePassword,
  
  // Email verification
  sendVerificationEmail: authClient.sendVerificationEmail,
  verifyEmail: authClient.verifyEmail,
  
  // Raw client for advanced usage
  $client: authClient,
};

// Default export for backward compatibility
export default authClient;
</file>

<file path="src/lib/auth/index.ts">
import { serverOnly } from "@tanstack/react-start";
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { reactStartCookies } from "better-auth/react-start";

import { db } from "~/db";
import { securityConfig } from "~/lib/security/config";

const getAuthConfig = serverOnly(() =>
  betterAuth({
    baseURL: process.env.VITE_BASE_URL,
    database: drizzleAdapter(db, {
      provider: "pg",
    }),

    // https://www.better-auth.com/docs/integrations/tanstack#usage-tips
    plugins: [reactStartCookies()],

    // Session configuration with security settings
    session: {
      expiresIn: securityConfig.session.maxAge,
      updateAge: securityConfig.session.updateAge,
      cookieCache: securityConfig.session.cookieCache,
    },

    // Secure cookie configuration
    advanced: {
      cookiePrefix: "solstice",
      useSecureCookies: securityConfig.cookies.secure,
      cookies: {
        sessionToken: {
          name: "session",
          options: securityConfig.cookies,
        },
        csrfToken: {
          name: "csrf",
          options: securityConfig.cookies,
        },
      },
    },

    // https://www.better-auth.com/docs/concepts/oauth
    socialProviders: {
      github: {
        clientId: process.env.GITHUB_CLIENT_ID!,
        clientSecret: process.env.GITHUB_CLIENT_SECRET!,
      },
      google: {
        clientId: process.env.GOOGLE_CLIENT_ID!,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      },
    },

    // https://www.better-auth.com/docs/authentication/email-password
    emailAndPassword: {
      enabled: true,
      requireEmailVerification: process.env.NODE_ENV === "production",
    },
  }),
);

export const auth = getAuthConfig();
</file>

<file path="src/styles.css">
@import "tailwindcss" source("./");

@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}

.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

- `pnpm dev` - Start development server
- `pnpm build` - Build for production  
- `pnpm start` - Start production server
- `pnpm lint` - Run ESLint
- `pnpm check-types` - Type checking with TypeScript
- `pnpm format` - Format code with Prettier
- `pnpm test` - Run Vitest tests
- `pnpm test:ui` - Run tests with UI
- `pnpm test:coverage` - Generate test coverage report
- `pnpm db` - Run Drizzle Kit database commands
- `pnpm auth:generate` - Generate auth schema from config

## Architecture Overview

This is **Solstice**, a sports league management platform built with TanStack Start (full-stack React framework) and deployed to Netlify. The application uses:

- **TanStack Router** for file-based routing with type safety
- **Better Auth** for authentication (email/password + OAuth via GitHub/Google)  
- **Drizzle ORM** with PostgreSQL for database operations
- **TanStack Query** for server state management and caching
- **Tailwind CSS** for styling with shadcn/ui components

### Key Architectural Patterns

**Full-Stack React with TanStack Start**: The app uses TanStack Start's server-side rendering and API routes. Server-only code is isolated using `serverOnly()` wrapper.

**Database & Auth Integration**: Better Auth uses Drizzle adapter for seamless integration. Auth schemas are auto-generated with `pnpm auth:generate` command.

**File-Based Routing**: Routes follow TanStack Router conventions in `src/routes/`. Route tree is auto-generated in `routeTree.gen.ts`.

**Server State Management**: React Query handles caching and synchronization. User authentication state is cached at the root level and passed through context.

### Key Directories (Features-Based Architecture)

- `src/app/` - Application-level code (providers, router setup)
- `src/features/` - Feature modules organized by domain
  - `auth/` - Authentication feature (components, hooks, API, tests)
  - Future features will follow the same pattern
- `src/shared/` - Shared resources across features
  - `ui/` - shadcn/ui components and icons
  - `hooks/` - Shared React hooks (useTheme, etc.)
  - `lib/` - Utilities and helpers
  - `types/` - Shared TypeScript types
- `src/db/` - Database layer
  - `schema/` - Drizzle schema definitions (single source of truth)
  - `migrations/` - Database migrations
- `src/routes/` - Thin route files that import from features
- `src/lib/` - Core infrastructure
  - `auth/` - Better Auth configuration
  - `env.ts` - Environment variable management
  - `security/` - Security utilities and middleware
- `src/tests/` - Test utilities and global test setup

### Environment Requirements

- `DATABASE_URL` - PostgreSQL connection string (pooled URL for serverless)
- `DATABASE_URL_UNPOOLED` - Direct connection URL for migrations (optional)
- `VITE_BASE_URL` - Application base URL
- `GITHUB_CLIENT_ID/SECRET` - GitHub OAuth
- `GOOGLE_CLIENT_ID/SECRET` - Google OAuth

Netlify automatically provides:
- `NETLIFY_DATABASE_URL` - Pooled Neon database URL
- `NETLIFY_DATABASE_URL_UNPOOLED` - Direct Neon database URL

### Database Connections

The app uses Neon with proper connection pooling:

- **Pooled connections** (`pooledDb`): For API routes and serverless functions
- **Unpooled connections** (`unpooledDb`): For migrations and long operations
- **Auto-detection** (`db`): Automatically selects based on environment

See `docs/database-connections.md` for detailed usage guide.

### Security Features

- **CSP Headers**: Content Security Policy with nonce-based script validation
- **Secure Cookies**: HTTPS-only, HttpOnly, SameSite protection in production
- **Rate Limiting**: Configurable rate limits for auth and API endpoints
- **Password Validation**: Strong password requirements enforced
- **Security Headers**: Full suite via Netlify Edge Functions

### Testing Infrastructure

- **Vitest**: Modern test runner with jsdom environment
- **Testing Library**: React component testing utilities
- **Coverage**: Code coverage reporting with c8
- **Mocks**: Auth and router mocks for isolated testing

### CI/CD Pipeline

- **GitHub Actions**: Automated testing, linting, and type checking
- **Netlify Deploy Previews**: Automatic preview deployments for PRs
- **Pre-commit Hooks**: Husky + lint-staged for code quality
- **Multi-version Testing**: Tests run on Node.js 18 and 20

### Code Organization Patterns

- **Auth Facade**: Clean API wrapper around Better Auth client
- **Theme Hook**: Reactive theme management with system preference support
- **Centralized Icons**: Reusable icon components in shared/ui/icons
- **Auth Guards**: Flexible authentication protection for routes
- **Environment Config**: Type-safe environment variable access
</file>

<file path="LICENSE">
// This license applies only to the original template in https://github.com/dotnize/react-tanstarter
// If you're using it to start your own project, feel free to remove or replace this file.

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>
</file>

<file path="netlify.toml">
[build]
  command = "pnpm build"
  publish = "dist"
  edge_functions = "netlify/edge-functions"

[build.environment]
  NODE_ENV = "production"

# Production context: Deploys from the production branch (main/master)
[context.production]
  command = "pnpm build"
  
[context.production.environment]
  NODE_ENV = "production"

# Deploy Preview context: Pull requests and preview deploys
[context.deploy-preview]
  command = "pnpm build"
  
[context.deploy-preview.environment]
  NODE_ENV = "test"

# Branch Deploy context: Deploys from branches (not main/master)
[context.branch-deploy]
  command = "pnpm build"
  
[context.branch-deploy.environment]
  NODE_ENV = "test"

[dev]
  targetPort = 5173
  publish = "dist"
  command = "pnpm dev"

# Security Headers (backup for edge function)
[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-Content-Type-Options = "nosniff"
    Referrer-Policy = "strict-origin-when-cross-origin"
    X-XSS-Protection = "1; mode=block"
    Permissions-Policy = "geolocation=(), microphone=(), camera=()"
    Strict-Transport-Security = "max-age=31536000; includeSubDomains; preload"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
</file>

<file path=".husky/pre-commit">
npx lint-staged
</file>

<file path="src/components/ThemeToggle.tsx">
import { useTheme } from "~/shared/hooks/useTheme";
import { Button } from "~/shared/ui/button";
import { MoonIcon, SunIcon } from "~/shared/ui/icons";

export default function ThemeToggle() {
  const { toggleTheme } = useTheme();

  return (
    <Button variant="outline" size="icon" type="button" onClick={toggleTheme}>
      <SunIcon className="size-4 scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
      <MoonIcon className="absolute size-4 scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  );
}
</file>

<file path="src/lib/auth-client.ts">
import { createAuthClient } from "better-auth/react";

// Create auth client instance
const authClient = createAuthClient({
  baseURL: import.meta.env.VITE_BASE_URL,
});

// Export a facade with all auth methods
export const auth = {
  // Authentication methods
  signIn: authClient.signIn,
  signUp: authClient.signUp,
  signOut: authClient.signOut,
  
  // OAuth methods
  signInWithOAuth: authClient.signIn.social,
  
  // Session methods
  getSession: authClient.getSession,
  useSession: authClient.useSession,
  
  // User methods  
  updateUser: authClient.updateUser,
  deleteUser: authClient.deleteUser,
  
  // Password methods
  forgetPassword: authClient.forgetPassword,
  resetPassword: authClient.resetPassword,
  changePassword: authClient.changePassword,
  
  // Email verification
  sendVerificationEmail: authClient.sendVerificationEmail,
  verifyEmail: authClient.verifyEmail,
  
  // Raw client for advanced usage
  $client: authClient,
};

// Default export for backward compatibility
export default authClient;
</file>

<file path=".prettierrc">
{
  "tabWidth": 2,
  "semi": true,
  "printWidth": 90,
  "singleQuote": false,
  "endOfLine": "lf",
  "trailingComma": "all",
  "plugins": ["prettier-plugin-organize-imports", "prettier-plugin-tailwindcss"]
}
</file>

<file path="docker-compose.yml">
services:
  db:
    image: postgres:alpine
    ports:
      - 5432:5432
    volumes:
      - postgres_data_tanstarter:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=tanstarter

volumes:
  postgres_data_tanstarter:
</file>

<file path="tsconfig.json">
{
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "isolatedModules": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "target": "ES2022",
    "allowJs": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./src/*"]
    },
    "noEmit": true,
          "strictNullChecks": true,
      "types": ["vite/client", "@tanstack/react-start"]
    }
  }
</file>

<file path="src/routes/(auth)/route.tsx">
import { createFileRoute, Outlet, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/(auth)")({
  component: RouteComponent,
  beforeLoad: async ({ context }) => {
    const REDIRECT_URL = "/dashboard";
    if (context.user) {
      throw redirect({
        to: REDIRECT_URL,
      });
    }
    return {
      redirectUrl: REDIRECT_URL,
    };
  },
});

function RouteComponent() {
  return (
    <div className="bg-background flex min-h-svh flex-col items-center justify-center gap-6 p-6 md:p-10">
      <div className="w-full max-w-sm">
        <Outlet />
      </div>
    </div>
  );
}
</file>

<file path="src/api.ts">
import {
  createStartAPIHandler,
  defaultAPIFileRouteHandler,
} from "@tanstack/react-start/api";

export default createStartAPIHandler(defaultAPIFileRouteHandler);
</file>

<file path="src/router.tsx">
import { QueryClient } from "@tanstack/react-query";
import { createRouter as createTanStackRouter } from "@tanstack/react-router";
import { routerWithQueryClient } from "@tanstack/react-router-with-query";

import { DefaultCatchBoundary } from "~/components/DefaultCatchBoundary";
import { NotFound } from "~/components/NotFound";
import { routeTree } from "./routeTree.gen";

export function createRouter() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false,
        staleTime: 1000 * 60 * 2, // 2 minutes
      },
    },
  });

  return routerWithQueryClient(
    createTanStackRouter({
      routeTree,
      context: { queryClient, user: null },
      defaultPreload: "intent",
      // react-query will handle data fetching & caching
      // https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#passing-all-loader-events-to-an-external-cache
      defaultPreloadStaleTime: 0,
      defaultErrorComponent: DefaultCatchBoundary,
      defaultNotFoundComponent: NotFound,
      scrollRestoration: true,
      defaultStructuralSharing: true,
    }),
    queryClient,
  );
}

declare module "@tanstack/react-router" {
  interface Register {
    router: ReturnType<typeof createRouter>;
  }
}
</file>

<file path="src/lib/server/db.ts">
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";

import * as schema from "../../db/schema";

const driver = postgres(process.env.DATABASE_URL as string);
export const db = drizzle({ client: driver, schema, casing: "snake_case" });
</file>

<file path="src/routes/api/auth/$.ts">
import { createServerFileRoute } from "@tanstack/react-start/server";
import { auth } from "~/lib/auth";

export const ServerRoute = createServerFileRoute("/api/auth/$").methods({
  GET: ({ request }) => {
    return auth.handler(request);
  },
  POST: ({ request }) => {
    return auth.handler(request);
  },
});
</file>

<file path=".env.example">
VITE_BASE_URL=http://localhost:3000

# Database Configuration
# For local development, use a single DATABASE_URL
DATABASE_URL="postgresql://user:password@localhost:5432/tanstarter"
# You can also use Docker Compose to set up a local PostgreSQL database:
# docker-compose up -d

# For production with Neon:
# The app automatically selects pooled/unpooled based on context

# Option 1: Use Netlify's automatic Neon integration
# Netlify automatically sets these when you connect a Neon database:
# NETLIFY_DATABASE_URL - Pooled connection URL (via pooler.neon.tech)
# NETLIFY_DATABASE_URL_UNPOOLED - Direct connection URL (via direct.neon.tech)

# Option 2: Manual Neon configuration
# DATABASE_URL - Your primary database URL (pooled for serverless)
# DATABASE_URL_UNPOOLED - Direct connection URL for migrations

# Option 3: Override with custom URLs
# DATABASE_POOLED_URL - Override for pooled connection
# DATABASE_UNPOOLED_URL - Override for unpooled connection

# Connection Type Usage:
# - Pooled: API routes, serverless functions, short queries
# - Unpooled: Migrations, batch operations, long-running queries

# pnpm run auth:secret
BETTER_AUTH_SECRET=

# OAuth2 Providers, optional
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=

# NOTE:
# In your OAuth2 apps, set callback/redirect URIs to`http://localhost:3000/api/auth/callback/<provider>`
# e.g. http://localhost:3000/api/auth/callback/github

# Security Configuration (optional)
# COOKIE_DOMAIN=.yourdomain.com
# OAUTH_ALLOWED_DOMAINS=yourdomain.com,trusted-partner.com
</file>

<file path="src/lib/server/auth.ts">
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";

import { db } from "./db";

export const auth = betterAuth({
  baseURL: process.env.VITE_BASE_URL,
  database: drizzleAdapter(db, {
    provider: "pg",
  }),

  // https://www.better-auth.com/docs/concepts/session-management#session-caching
  session: {
    cookieCache: {
      enabled: true,
      maxAge: 5 * 60, // 5 minutes
    },
  },


  // https://www.better-auth.com/docs/concepts/oauth
  socialProviders: {
    github: {
      clientId: process.env.GITHUB_CLIENT_ID!,
      clientSecret: process.env.GITHUB_CLIENT_SECRET!,
    },
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    },
    discord: {
      clientId: process.env.DISCORD_CLIENT_ID!,
      clientSecret: process.env.DISCORD_CLIENT_SECRET!,
    },
  },

  // https://www.better-auth.com/docs/authentication/email-password
  emailAndPassword: {
    enabled: true,
    // Uncomment if email verification is required
    // verifyEmail: true,
  },
});
</file>

<file path="src/routes/(auth)/login.tsx">
import { createFileRoute } from "@tanstack/react-router";
import LoginForm from "~/features/auth/components/login";

export const Route = createFileRoute("/(auth)/login")({
  component: LoginForm,
});
</file>

<file path="src/routes/(auth)/signup.tsx">
import { createFileRoute } from "@tanstack/react-router";
import SignupForm from "~/features/auth/components/signup";

export const Route = createFileRoute("/(auth)/signup")({
  component: SignupForm,
});
</file>

<file path="src/routes/dashboard/index.tsx">
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard/")({
  component: DashboardIndex,
});

function DashboardIndex() {
  return (
    <div className="flex flex-col items-center gap-1">
      Dashboard index page
      <pre className="bg-card text-card-foreground rounded-md border p-1">
        routes/dashboard/index.tsx
      </pre>
    </div>
  );
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/styles.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "~/components",
    "utils": "~/lib/utils",
    "ui": "~/components/ui",
    "lib": "~/lib",
    "hooks": "~/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="drizzle.config.ts">
import type { Config } from "drizzle-kit";

// Use unpooled connection for migrations
// Priority: DATABASE_URL_UNPOOLED > NETLIFY_DATABASE_URL_UNPOOLED > DATABASE_URL
const getDatabaseUrl = () => {
  return process.env.DATABASE_URL_UNPOOLED || 
         process.env.NETLIFY_DATABASE_URL_UNPOOLED || 
         process.env.DATABASE_URL as string;
};

export default {
  out: "./src/db/migrations",
  schema: "./src/db/schema/index.ts",
  breakpoints: true,
  verbose: true,
  strict: true,
  dialect: "postgresql",
  casing: "snake_case",
  dbCredentials: {
    url: getDatabaseUrl(),
  },
} satisfies Config;
</file>

<file path="eslint.config.js">
import react from "@eslint-react/eslint-plugin";
import js from "@eslint/js";
import pluginQuery from "@tanstack/eslint-plugin-query";
import pluginRouter from "@tanstack/eslint-plugin-router";
import eslintConfigPrettier from "eslint-config-prettier";
import * as reactHooks from "eslint-plugin-react-hooks";
import tseslint from "typescript-eslint";

export default tseslint.config(
  {
    ignores: ["dist", ".wrangler", ".vercel", ".netlify", ".output", "build/", ".nitro/**", "coverage/**", "**/*.gen.ts", "node_modules/**"],
  },
  {
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      parser: tseslint.parser,
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
    extends: [
      js.configs.recommended,
      ...tseslint.configs.recommended,
      eslintConfigPrettier,
      ...pluginQuery.configs["flat/recommended"],
      ...pluginRouter.configs["flat/recommended"],
      reactHooks.configs.recommended,
      react.configs["recommended-type-checked"],
      // ...you can add plugins or configs here
    ],
    rules: {
      // You can override any rules here
      "react-hooks/react-compiler": "warn",
    },
  }
);
</file>

<file path="vite.config.ts">
import tailwindcss from "@tailwindcss/vite";
import { tanstackStart } from "@tanstack/react-start/plugin/vite";
import { defineConfig } from "vite";
import tsConfigPaths from "vite-tsconfig-paths";

export default defineConfig({
  plugins: [
    tsConfigPaths({
      projects: ["./tsconfig.json"],
    }),
    tailwindcss(),
    tanstackStart({
      // https://react.dev/learn/react-compiler
      react: {
        babel: {
          plugins: [
            [
              "babel-plugin-react-compiler",
              {
                target: "19",
              },
            ],
          ],
        },
      },

      tsr: {
        quoteStyle: "double",
        semicolons: true,
        // verboseFileRoutes: false,
      },

      // Netlify deployment target
      target: "netlify",
    }),
  ],
});
</file>

<file path="src/routes/__root.tsx">
/// <reference types="vite/client" />
import type { QueryClient } from "@tanstack/react-query";
import {
  createRootRouteWithContext,
  HeadContent,
  Outlet,
  ScriptOnce,
  Scripts,
} from "@tanstack/react-router";

import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { TanStackRouterDevtools } from "@tanstack/react-router-devtools";

import { getUser } from "~/lib/auth/functions/getUser";
import appCss from "~/styles.css?url";

export const Route = createRootRouteWithContext<{
  queryClient: QueryClient;
  user: Awaited<ReturnType<typeof getUser>>;
}>()({
  beforeLoad: async ({ context }) => {
    const user = await context.queryClient.fetchQuery({
      queryKey: ["user"],
      queryFn: ({ signal }) => getUser({ signal }),
    }); // we're using react-query for caching, see router.tsx
    return { user };
  },
  head: () => ({
    meta: [
      {
        charSet: "utf-8",
      },
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1",
      },
      {
        title: "React TanStarter",
      },
      {
        name: "description",
        content: "A minimal starter template for üèùÔ∏è TanStack Start.",
      },
    ],
    links: [{ rel: "stylesheet", href: appCss }],
  }),
  component: RootComponent,
});

function RootComponent() {
  return (
    <RootDocument>
      <Outlet />
    </RootDocument>
  );
}

function RootDocument({ children }: { readonly children: React.ReactNode }) {
  return (
    // suppress since we're updating the "dark" class in a custom script below
    <html lang="en" suppressHydrationWarning>
      <head>
        <HeadContent />
      </head>
      <body>
        <ScriptOnce>
          {`document.documentElement.classList.toggle(
            'dark',
            localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)
            )`}
        </ScriptOnce>

        {children}

        <ReactQueryDevtools buttonPosition="bottom-left" />
        <TanStackRouterDevtools position="bottom-right" />

        <Scripts />
      </body>
    </html>
  );
}
</file>

<file path="src/routeTree.gen.ts">
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { createServerRootRoute } from "@tanstack/react-start/server";

import { Route as rootRouteImport } from "./routes/__root";
import { Route as DashboardRouteRouteImport } from "./routes/dashboard/route";
import { Route as authRouteRouteImport } from "./routes/(auth)/route";
import { Route as IndexRouteImport } from "./routes/index";
import { Route as DashboardIndexRouteImport } from "./routes/dashboard/index";
import { Route as authSignupRouteImport } from "./routes/(auth)/signup";
import { Route as authLoginRouteImport } from "./routes/(auth)/login";
import { ServerRoute as ApiAuthSplatServerRouteImport } from "./routes/api/auth/$";

const rootServerRouteImport = createServerRootRoute();

const DashboardRouteRoute = DashboardRouteRouteImport.update({
  id: "/dashboard",
  path: "/dashboard",
  getParentRoute: () => rootRouteImport,
} as any);
const authRouteRoute = authRouteRouteImport.update({
  id: "/(auth)",
  getParentRoute: () => rootRouteImport,
} as any);
const IndexRoute = IndexRouteImport.update({
  id: "/",
  path: "/",
  getParentRoute: () => rootRouteImport,
} as any);
const DashboardIndexRoute = DashboardIndexRouteImport.update({
  id: "/",
  path: "/",
  getParentRoute: () => DashboardRouteRoute,
} as any);
const authSignupRoute = authSignupRouteImport.update({
  id: "/signup",
  path: "/signup",
  getParentRoute: () => authRouteRoute,
} as any);
const authLoginRoute = authLoginRouteImport.update({
  id: "/login",
  path: "/login",
  getParentRoute: () => authRouteRoute,
} as any);
const ApiAuthSplatServerRoute = ApiAuthSplatServerRouteImport.update({
  id: "/api/auth/$",
  path: "/api/auth/$",
  getParentRoute: () => rootServerRouteImport,
} as any);

export interface FileRoutesByFullPath {
  "/": typeof authRouteRouteWithChildren;
  "/dashboard": typeof DashboardRouteRouteWithChildren;
  "/login": typeof authLoginRoute;
  "/signup": typeof authSignupRoute;
  "/dashboard/": typeof DashboardIndexRoute;
}
export interface FileRoutesByTo {
  "/": typeof authRouteRouteWithChildren;
  "/login": typeof authLoginRoute;
  "/signup": typeof authSignupRoute;
  "/dashboard": typeof DashboardIndexRoute;
}
export interface FileRoutesById {
  __root__: typeof rootRouteImport;
  "/": typeof IndexRoute;
  "/(auth)": typeof authRouteRouteWithChildren;
  "/dashboard": typeof DashboardRouteRouteWithChildren;
  "/(auth)/login": typeof authLoginRoute;
  "/(auth)/signup": typeof authSignupRoute;
  "/dashboard/": typeof DashboardIndexRoute;
}
export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath;
  fullPaths: "/" | "/dashboard" | "/login" | "/signup" | "/dashboard/";
  fileRoutesByTo: FileRoutesByTo;
  to: "/" | "/login" | "/signup" | "/dashboard";
  id:
    | "__root__"
    | "/"
    | "/(auth)"
    | "/dashboard"
    | "/(auth)/login"
    | "/(auth)/signup"
    | "/dashboard/";
  fileRoutesById: FileRoutesById;
}
export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute;
  authRouteRoute: typeof authRouteRouteWithChildren;
  DashboardRouteRoute: typeof DashboardRouteRouteWithChildren;
}
export interface FileServerRoutesByFullPath {
  "/api/auth/$": typeof ApiAuthSplatServerRoute;
}
export interface FileServerRoutesByTo {
  "/api/auth/$": typeof ApiAuthSplatServerRoute;
}
export interface FileServerRoutesById {
  __root__: typeof rootServerRouteImport;
  "/api/auth/$": typeof ApiAuthSplatServerRoute;
}
export interface FileServerRouteTypes {
  fileServerRoutesByFullPath: FileServerRoutesByFullPath;
  fullPaths: "/api/auth/$";
  fileServerRoutesByTo: FileServerRoutesByTo;
  to: "/api/auth/$";
  id: "__root__" | "/api/auth/$";
  fileServerRoutesById: FileServerRoutesById;
}
export interface RootServerRouteChildren {
  ApiAuthSplatServerRoute: typeof ApiAuthSplatServerRoute;
}

declare module "@tanstack/react-router" {
  interface FileRoutesByPath {
    "/dashboard": {
      id: "/dashboard";
      path: "/dashboard";
      fullPath: "/dashboard";
      preLoaderRoute: typeof DashboardRouteRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/(auth)": {
      id: "/(auth)";
      path: "/";
      fullPath: "/";
      preLoaderRoute: typeof authRouteRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/": {
      id: "/";
      path: "/";
      fullPath: "/";
      preLoaderRoute: typeof IndexRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/dashboard/": {
      id: "/dashboard/";
      path: "/";
      fullPath: "/dashboard/";
      preLoaderRoute: typeof DashboardIndexRouteImport;
      parentRoute: typeof DashboardRouteRoute;
    };
    "/(auth)/signup": {
      id: "/(auth)/signup";
      path: "/signup";
      fullPath: "/signup";
      preLoaderRoute: typeof authSignupRouteImport;
      parentRoute: typeof authRouteRoute;
    };
    "/(auth)/login": {
      id: "/(auth)/login";
      path: "/login";
      fullPath: "/login";
      preLoaderRoute: typeof authLoginRouteImport;
      parentRoute: typeof authRouteRoute;
    };
  }
}
declare module "@tanstack/react-start/server" {
  interface ServerFileRoutesByPath {
    "/api/auth/$": {
      id: "/api/auth/$";
      path: "/api/auth/$";
      fullPath: "/api/auth/$";
      preLoaderRoute: typeof ApiAuthSplatServerRouteImport;
      parentRoute: typeof rootServerRouteImport;
    };
  }
}

interface authRouteRouteChildren {
  authLoginRoute: typeof authLoginRoute;
  authSignupRoute: typeof authSignupRoute;
}

const authRouteRouteChildren: authRouteRouteChildren = {
  authLoginRoute: authLoginRoute,
  authSignupRoute: authSignupRoute,
};

const authRouteRouteWithChildren = authRouteRoute._addFileChildren(
  authRouteRouteChildren,
);

interface DashboardRouteRouteChildren {
  DashboardIndexRoute: typeof DashboardIndexRoute;
}

const DashboardRouteRouteChildren: DashboardRouteRouteChildren = {
  DashboardIndexRoute: DashboardIndexRoute,
};

const DashboardRouteRouteWithChildren = DashboardRouteRoute._addFileChildren(
  DashboardRouteRouteChildren,
);

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  authRouteRoute: authRouteRouteWithChildren,
  DashboardRouteRoute: DashboardRouteRouteWithChildren,
};
export const routeTree = rootRouteImport
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>();
const rootServerRouteChildren: RootServerRouteChildren = {
  ApiAuthSplatServerRoute: ApiAuthSplatServerRoute,
};
export const serverRouteTree = rootServerRouteImport
  ._addFileChildren(rootServerRouteChildren)
  ._addFileTypes<FileServerRouteTypes>();
</file>

<file path=".gitignore">
node_modules

# Ignore lockfiles we don't use
# package-lock.json
# yarn.lock
# pnpm-lock.yaml
# bun.lock

.DS_Store
.cache
.env
.env.local
.env.*.local
*.log

.data
.vercel
.output
.wrangler
.netlify
.sst
dist
/build/
/api/
/server/build
/public/build

.tanstack

# Testing
coverage
.nyc_output
*.lcov
</file>

<file path=".prettierignore">
# lockfiles
pnpm-lock.yaml
package-lock.json
yarn.lock
bun.lock

# misc
routeTree.gen.ts
.tanstack/
drizzle/
.drizzle/

# build outputs
.vercel
.output
.wrangler
.netlify
dist
</file>

<file path="src/routes/dashboard/route.tsx">
import { createFileRoute, Link, Outlet, redirect } from "@tanstack/react-router";
import { Button } from "~/shared/ui/button";

export const Route = createFileRoute("/dashboard")({
  component: DashboardLayout,
  beforeLoad: async ({ context }) => {
    if (!context.user) {
      throw redirect({ to: "/login" });
    }

    // `context.queryClient` is also available in our loaders
    // https://tanstack.com/start/latest/docs/framework/react/examples/start-basic-react-query
    // https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading
  },
});

function DashboardLayout() {
  return (
    <div className="flex min-h-svh flex-col items-center justify-center gap-10 p-2">
      <div className="flex flex-col items-center gap-4">
        <h1 className="text-3xl font-bold sm:text-4xl">Dashboard Layout</h1>
        <div className="flex items-center gap-2 max-sm:flex-col">
          This is a protected layout:
          <pre className="bg-card text-card-foreground rounded-md border p-1">
            routes/dashboard/route.tsx
          </pre>
        </div>

        <Button type="button" asChild className="w-fit" size="lg">
          <Link to="/">Back to index</Link>
        </Button>
      </div>

      <Outlet />
    </div>
  );
}
</file>

<file path="src/routes/index.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { createFileRoute, Link, useRouter } from "@tanstack/react-router";
import ThemeToggle from "~/components/ThemeToggle";
import { auth } from "~/lib/auth-client";
import { Button } from "~/shared/ui/button";

export const Route = createFileRoute("/")({
  component: Home,
  loader: ({ context }) => {
    return { user: context.user };
  },
});

function Home() {
  // Home component for the landing page
  const { user } = Route.useLoaderData();
  const queryClient = useQueryClient();
  const router = useRouter();

  return (
    <div className="flex min-h-svh flex-col items-center justify-center gap-10 p-2">
      <div className="flex flex-col items-center gap-4">
        <h1 className="text-3xl font-bold sm:text-4xl">React TanStarter</h1>
        <div className="flex items-center gap-2 max-sm:flex-col">
          This is an unprotected page:
          <pre className="bg-card text-card-foreground rounded-md border p-1">
            routes/index.tsx
          </pre>
        </div>
      </div>

      {user ? (
        <div className="flex flex-col items-center gap-2">
          <p>Welcome back, {user.name}!</p>
          <Button type="button" asChild className="mb-2 w-fit" size="lg">
            <Link to="/dashboard">Go to Dashboard</Link>
          </Button>
          <div className="text-center text-xs sm:text-sm">
            Session user:
            <pre className="max-w-screen overflow-x-auto px-2 text-start">
              {JSON.stringify(user, null, 2)}
            </pre>
          </div>

          <Button
            onClick={async () => {
              await auth.signOut();
              await queryClient.invalidateQueries({ queryKey: ["user"] });
              await router.invalidate();
            }}
            type="button"
            className="w-fit"
            variant="destructive"
            size="lg"
          >
            Sign out
          </Button>
        </div>
      ) : (
        <div className="flex flex-col items-center gap-2">
          <p>You are not signed in.</p>
          <Button type="button" asChild className="w-fit" size="lg">
            <Link to="/login">Log in</Link>
          </Button>
        </div>
      )}

      <div className="flex flex-col items-center gap-2">
        <ThemeToggle />
        <a
          className="text-muted-foreground hover:text-foreground underline"
          href="https://github.com/dotnize/react-tanstarter"
          target="_blank"
          rel="noreferrer noopener"
        >
          dotnize/react-tanstarter
        </a>
      </div>
    </div>
  );
}
</file>

<file path="README.md">
# Solstice

[![CI](https://github.com/soleilheaney/solstice/actions/workflows/ci.yml/badge.svg)](https://github.com/soleilheaney/solstice/actions/workflows/ci.yml)
[![codecov](https://codecov.io/gh/soleilheaney/solstice/branch/main/graph/badge.svg)](https://codecov.io/gh/soleilheaney/solstice)
[![Deploy Preview](https://github.com/soleilheaney/solstice/actions/workflows/deploy-preview.yml/badge.svg)](https://github.com/soleilheaney/solstice/actions/workflows/deploy-preview.yml)

## Sports Registration Platform

Solstice is a **modern web platform for managing memberships, teams, and events**. Built with [TanStack Start](https://tanstack.com/start) and deployed on [Netlify](https://www.netlify.com/).

## Prerequisites

- Node.js (v18+ or v20+)
- pnpm (v9+)
- PostgreSQL database

## Environment Variables

Create a `.env` file in the project root with the following variables:

```env
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/solstice

# Application
VITE_BASE_URL=http://localhost:3000

# OAuth Providers (optional)
GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
```

## Project Structure

- `src/routes/` - File-based routing (pages and API endpoints)
- `src/lib/auth/` - Better Auth configuration and functions
- `src/lib/db/` - Drizzle database setup and schemas
- `src/lib/server/` - Server-side database schemas
- `src/components/ui/` - shadcn/ui components

## Development

1. Install dependencies:
   ```bash
   pnpm install
   ```

2. Set up the database:
   ```bash
   pnpm db push
   ```

3. Generate auth schemas:
   ```bash
   pnpm auth:generate
   ```

4. Run the development server:
   ```bash
   pnpm dev
   ```

## Available Scripts

- `pnpm dev` - Start development server
- `pnpm build` - Build for production
- `pnpm start` - Start production server
- `pnpm lint` - Run ESLint
- `pnpm check-types` - Type checking with TypeScript
- `pnpm format` - Format code with Prettier
- `pnpm test` - Run tests
- `pnpm test:coverage` - Run tests with coverage
- `pnpm db` - Run Drizzle Kit database commands
- `pnpm auth:generate` - Generate auth schema from config

## Deployment

The application is automatically deployed to Netlify:

- **Production**: Pushes to `main` branch trigger production deployments
- **Preview**: Pull requests get automatic preview deployments

## CI/CD

GitHub Actions workflows handle:

- **Continuous Integration**: Linting, type checking, and testing on Node.js 18 and 20
- **Deploy Previews**: Automatic Netlify preview deployments for pull requests
- **Code Coverage**: Test coverage reports uploaded to Codecov

### Required GitHub Secrets

Configure these secrets in your GitHub repository settings:

- `DATABASE_URL` - PostgreSQL connection string for CI tests
- `VITE_BASE_URL` - Base URL for the application
- `NETLIFY_AUTH_TOKEN` - Netlify authentication token
- `NETLIFY_SITE_ID` - Netlify site ID
- `CODECOV_TOKEN` - Codecov upload token (optional)
- `GITHUB_CLIENT_ID` - GitHub OAuth client ID
- `GITHUB_CLIENT_SECRET` - GitHub OAuth client secret
- `GOOGLE_CLIENT_ID` - Google OAuth client ID
- `GOOGLE_CLIENT_SECRET` - Google OAuth client secret

Solstice is a **modern web platform for managing memberships, teams, and events**. It leverages a cutting-edge tech stack to deliver fast, dynamic user experiences while being highly extensible.

## Overview and Purpose

The Solstice platform streamlines sports league management ‚Äì initially serving **Quadball Canada** (the national quadball governing body) and eventually adaptable to other sports organizations. The platform enables athletes, team leaders, and administrators to handle all essential activities in one place.

**Key Features:**

- **Member Registration & Management:** User accounts, profiles, waivers, and annual memberships
- **Team Setup & Roster Management:** Team creation, player invitations, and roster management
- **Event Creation & Registration:** Tournament/league management with team/individual registration
- **Payments & Finance:** Integration with a payment platform for membership and event fees
- **Role-Based Access Control:** Admin, Team Lead, and Player permission layers
- **Communication & Notifications:** Email confirmations and announcements
- **Future Extensibility:** Multi-organization, multi-sport capability
</file>

<file path="package.json">
{
  "name": "tanstarter",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "start": "node .output/server/index.mjs",
    "lint": "eslint .",
    "check-types": "tsc --noEmit",
    "format": "prettier --write .",
    "db": "drizzle-kit",
    "deps": "pnpm dlx npm-check-updates@latest --interactive --format group",
    "ui": "pnpm dlx shadcn@latest",
    "auth:secret": "pnpm dlx @better-auth/cli@latest secret",
    "auth:generate": "pnpm dlx @better-auth/cli@latest generate --config ./src/lib/auth/index.ts --y --output ./src/lib/db/schema/auth.schema.ts && prettier --write ./src/lib/db/schema/auth.schema.ts",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:watch": "vitest --watch",
    "prepare": "husky"
  },
  "dependencies": {
    "@neondatabase/serverless": "^1.0.1",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@tanstack/react-query": "^5.80.6",
    "@tanstack/react-query-devtools": "^5.80.6",
    "@tanstack/react-router": "^1.121.2",
    "@tanstack/react-router-devtools": "^1.121.2",
    "@tanstack/react-router-with-query": "^1.121.2",
    "@tanstack/react-start": "^1.121.2",
    "@vercel/postgres": "^0.10.0",
    "better-auth": "^1.2.9",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "drizzle-orm": "^0.44.2",
    "lucide-react": "^0.514.0",
    "postgres": "^3.4.7",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "tailwind-merge": "^3.3.1",
    "vite": "^6.3.5"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,md,json}": "prettier --write"
  },
  "devDependencies": {
    "@eslint-react/eslint-plugin": "^1.52.1",
    "@eslint/js": "^9.28.0",
    "@netlify/edge-functions": "^2.14.5",
    "@tailwindcss/vite": "^4.1.9",
    "@tanstack/eslint-plugin-query": "^5.78.0",
    "@tanstack/eslint-plugin-router": "^1.120.17",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^24.0.0",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.5.2",
    "@vitest/coverage-v8": "^3.2.3",
    "babel-plugin-react-compiler": "latest",
    "dotenv-expand": "^12.0.2",
    "drizzle-kit": "^0.31.1",
    "eslint": "^9.28.0",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-react-hooks": "6.0.0-rc.1",
    "husky": "^9.1.7",
    "jsdom": "^26.1.0",
    "lint-staged": "^16.1.1",
    "prettier": "^3.5.3",
    "prettier-plugin-organize-imports": "^4.1.0",
    "prettier-plugin-tailwindcss": "^0.6.12",
    "tailwindcss": "^4.1.9",
    "tw-animate-css": "^1.3.4",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.34.0",
    "vite-tsconfig-paths": "^5.1.4",
    "vitest": "^3.2.3"
  }
}
</file>

</files>
